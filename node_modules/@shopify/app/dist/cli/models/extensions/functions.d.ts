/// <reference types="node" />
import { BaseFunctionConfigurationSchema, BaseFunctionMetadataSchema } from './schemas.js';
import { schema, abort } from '@shopify/cli-kit';
import { Result } from '@shopify/cli-kit/common/result';
import { Writable } from 'stream';
declare type FunctionConfigType = schema.define.infer<typeof BaseFunctionConfigurationSchema>;
declare type MetadataType = schema.define.infer<typeof BaseFunctionMetadataSchema>;
declare type LoadFunctionError = 'invalid_function_type' | 'invalid_function_config' | 'invalid_function_metadata';
/**
 * Specification with all the needed properties and methods to load a function.
 */
export interface FunctionSpec<TConfiguration extends FunctionConfigType = FunctionConfigType, TMetadata extends MetadataType = MetadataType> {
    identifier: string;
    externalType: string;
    externalName: string;
    helpURL?: string;
    public?: boolean;
    templateURL?: string;
    languages?: {
        name: string;
        value: string;
    }[];
    configSchema?: schema.define.ZodType<TConfiguration>;
    metadataSchema?: schema.define.ZodType<TMetadata>;
    templatePath?: (lang: string) => string;
    validate?: <T extends TConfiguration>(config: T) => unknown;
}
/**
 * Class that represents an instance of a local function
 * Before creating this class we've validated that:
 * - There is a spec for this type of function
 * - The Config Schema for that spec is followed by the function config toml file
 * - The Metadata Schema for that spec is followed by the function metadata file
 *
 * This class holds the public interface to interact with functions
 */
export declare class FunctionInstance<TConfiguration extends FunctionConfigType = FunctionConfigType, TMetadata extends MetadataType = MetadataType> {
    private config;
    private metadata;
    private specification;
    private directory;
    private localIdentifier;
    get type(): string;
    constructor(config: TConfiguration, metadata: TMetadata, specification: FunctionSpec<TConfiguration>, directory: string);
    get inputQueryPath(): string;
    get wasmPath(): string;
    validate(): unknown;
    build(stdout: Writable, stderr: Writable, signal: abort.Signal): Promise<void>;
    publishURL(options: {
        orgId: string;
        appId: string;
    }): Promise<string>;
}
/**
 * Given a path, read the type first, find the correct spec and load the function.
 *
 * If there is no spec for that type, return undefined.
 * Loading the function can fail if the config fail doesn't follow the given Schema
 */
export declare function loadFunction(configPath: string): Promise<Result<FunctionInstance, LoadFunctionError>>;
export declare function createFunctionSpec<TConfiguration extends FunctionConfigType = FunctionConfigType, TMetadata extends MetadataType = MetadataType>(spec: FunctionSpec<TConfiguration, TMetadata>): FunctionSpec<TConfiguration, TMetadata>;
export {};
