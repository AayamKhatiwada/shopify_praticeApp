import { TypeSchema } from './schemas.js';
import { bundleExtension } from '../../services/extensions/bundle.js';
import { id, path, toml, file, output, environment } from '@shopify/cli-kit';
import { err, ok } from '@shopify/cli-kit/common/result';
// Array with all registered extensions (locally)
// PENDING: Register and load all extensions
const AllLocalSpecs = [];
/**
 * Class that represents an instance of a local extension
 * Before creating this class we've validated that:
 * - There is a spec for this type of extension
 * - The Schema for that spec is followed by the extension config toml file
 * - We were able to find an entry point file for that extension
 *
 * It supports extension points, making this Class compatible with both new ui-extension
 * and legacy extension types. Extension points are optional and this class will handle them if present.
 *
 * This class holds the public interface to interact with extensions
 */
export class ExtensionInstance {
    constructor(config, entryPath, directory, specification, remoteSpecification, extensionPointSpecs) {
        this.config = config;
        this.entryPath = entryPath;
        this.directory = directory;
        this.specification = specification;
        this.remoteSpecification = remoteSpecification;
        this.extensionPointSpecs = extensionPointSpecs;
        this.outputPath = `${this.directory}/dist/main.js`;
        this.devUUID = `dev-${id.generateRandomUUID()}`;
        this.localIdentifier = path.basename(directory);
    }
    get type() {
        return this.specification.identifier;
    }
    get humanName() {
        return this.remoteSpecification?.externalName;
    }
    async build(stderr, stdout, app) {
        await bundleExtension({
            minify: true,
            outputBundlePath: this.outputPath,
            sourceFilePath: this.entryPath,
            environment: 'production',
            env: app.dotenv?.variables ?? {},
            stderr,
            stdout,
        });
        stdout.write(`${this.localIdentifier} successfully built`);
    }
    deployConfig() {
        return this.specification.deployConfig?.(this.config, this.directory) ?? {};
    }
    validate() {
        if (!this.specification.preDeployValidation)
            return true;
        return this.specification.preDeployValidation(this.config);
    }
    resourceUrl() {
        if (this.extensionPointSpecs) {
            return this.extensionPointSpecs.map((point) => {
                const conf = this.config.extension_points?.find((spec) => spec.type === point.type);
                if (!conf)
                    return { type: point.type, url: undefined };
                return { type: point.type, url: this.extensionPointURL(point, conf) };
            });
        }
        else {
            return this.specification.resourceUrl?.(this.config) ?? '';
        }
    }
    async publishURL(options) {
        const partnersFqdn = await environment.fqdn.partners();
        const parnersPath = this.specification.partnersWebId;
        return `https://${partnersFqdn}/${options.orgId}/apps/${options.appId}/extensions/${parnersPath}/${options.extensionId}`;
    }
    previewMessage(url, storeFqdn) {
        if (this.specification.previewMessage)
            return this.specification.previewMessage(url, this.devUUID, this.config, storeFqdn);
        const publicURL = `${url}/extensions/${this.devUUID}`;
        return output.content `Preview link: ${publicURL}`;
    }
    extensionPointURL(point, config) {
        return point.resourceUrl?.(config) ?? '';
    }
}
/**
 * Find the registered spececification for a given extension type
 */
function specForType(type) {
    return AllLocalSpecs.find((spec) => spec.identifier === type);
}
// PENDING: Fetch remote specs
function remoteSpecForType(type) {
    return undefined;
}
/**
 * Load an extension from given a path.
 * 1. Find the entryPoint file
 * 2. Read the type and find the registered spec for that type.
 * 3. Parse the config file using the schema from the spec
 *
 * If that fails the extension can't be loaded and we'll return an error (to be handled by the caller)
 */
export async function loadExtension(configPath) {
    const directory = path.dirname(configPath);
    // Find entry paths
    const entryPath = await path.glob(path.join(directory, 'src', '*.+(ts|js|tsx|jsx)'));
    if (!entryPath[0])
        return err('invalid_entry_path');
    // Read Config file
    const fileContent = await file.read(configPath);
    const obj = toml.decode(fileContent);
    const { type } = TypeSchema.parse(obj);
    // Find spec for this type
    const localSpec = specForType(type);
    const remoteSpec = remoteSpecForType(type);
    if (!localSpec)
        return err('invalid_extension_type');
    // Parse config for this extension type schema
    let config;
    try {
        config = localSpec.schema.parse(obj);
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch {
        return err('invalid_config');
    }
    // PENDING: Add support for extension points and validate them
    const instance = new ExtensionInstance(config, entryPath[0], directory, localSpec, remoteSpec, []);
    return ok(instance);
}
export function createExtensionSpec(spec) {
    return spec;
}
//# sourceMappingURL=extensions.js.map