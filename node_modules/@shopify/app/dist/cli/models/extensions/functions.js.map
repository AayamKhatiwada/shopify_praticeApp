{"version":3,"file":"functions.js","sourceRoot":"","sources":["../../../../src/cli/models/extensions/functions.ts"],"names":[],"mappings":"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","sourcesContent":["import {BaseFunctionConfigurationSchema, BaseFunctionMetadataSchema, TypeSchema} from './schemas.js'\nimport {toml, schema, file, path, error, system, abort} from '@shopify/cli-kit'\nimport {err, ok, Result} from '@shopify/cli-kit/common/result'\nimport {fqdn} from '@shopify/cli-kit/src/environment.js'\nimport {Writable} from 'stream'\n\n// Base config types that all config schemas must extend\ntype FunctionConfigType = schema.define.infer<typeof BaseFunctionConfigurationSchema>\ntype MetadataType = schema.define.infer<typeof BaseFunctionMetadataSchema>\n\n// Array with all registered functions\nconst AllSpecs: FunctionSpec[] = []\ntype LoadFunctionError = 'invalid_function_type' | 'invalid_function_config' | 'invalid_function_metadata'\n\n/**\n * Specification with all the needed properties and methods to load a function.\n */\nexport interface FunctionSpec<\n  TConfiguration extends FunctionConfigType = FunctionConfigType,\n  TMetadata extends MetadataType = MetadataType,\n> {\n  identifier: string\n  externalType: string\n  externalName: string\n  helpURL?: string\n  public?: boolean\n  templateURL?: string\n  languages?: {name: string; value: string}[]\n  configSchema?: schema.define.ZodType<TConfiguration>\n  metadataSchema?: schema.define.ZodType<TMetadata>\n  templatePath?: (lang: string) => string\n  validate?: <T extends TConfiguration>(config: T) => unknown\n}\n\n/**\n * Class that represents an instance of a local function\n * Before creating this class we've validated that:\n * - There is a spec for this type of function\n * - The Config Schema for that spec is followed by the function config toml file\n * - The Metadata Schema for that spec is followed by the function metadata file\n *\n * This class holds the public interface to interact with functions\n */\nexport class FunctionInstance<\n  TConfiguration extends FunctionConfigType = FunctionConfigType,\n  TMetadata extends MetadataType = MetadataType,\n> {\n  private config: TConfiguration\n  private metadata: TMetadata\n  private specification: FunctionSpec<TConfiguration>\n  private directory: string\n  private localIdentifier: string\n\n  get type() {\n    return this.specification.identifier\n  }\n\n  constructor(\n    config: TConfiguration,\n    metadata: TMetadata,\n    specification: FunctionSpec<TConfiguration>,\n    directory: string,\n  ) {\n    this.config = config\n    this.metadata = metadata\n    this.specification = specification\n    this.directory = directory\n    this.localIdentifier = path.basename(directory)\n  }\n\n  get inputQueryPath() {\n    return `${this.directory}/input.graphql`\n  }\n\n  get wasmPath() {\n    const relativePath = this.config.build.path ?? 'dist/index.wasm'\n    return `${this.directory}/${relativePath}`\n  }\n\n  validate() {\n    return this.specification.validate?.(this.config)\n  }\n\n  async build(stdout: Writable, stderr: Writable, signal: abort.Signal) {\n    const buildCommand = this.config.build.command\n    if (!buildCommand || buildCommand.trim() === '') {\n      stderr.write(`The function extension ${this.localIdentifier} doesn't have a build command or it's empty`)\n      stderr.write(`\n      Edit the shopify.function.extension.toml configuration file and set how to build the extension.\n\n      [build]\n      command = \"{COMMAND}\"\n\n      Note that the command must output a dist/index.wasm file.\n      `)\n      throw new error.AbortSilent()\n    }\n    const buildCommandComponents = buildCommand.split(' ')\n    stdout.write(`Building function ${this.localIdentifier}...`)\n    await system.exec(buildCommandComponents[0]!, buildCommandComponents.slice(1), {\n      stdout,\n      stderr,\n      cwd: this.directory,\n      signal,\n    })\n  }\n\n  async publishURL(options: {orgId: string; appId: string}) {\n    const partnersFqdn = await fqdn.partners()\n    return `https://${partnersFqdn}/${options.orgId}/apps/${options.appId}/extensions`\n  }\n}\n\n/**\n * Find the registered spec for a given function type\n */\nfunction specForType(type: string): FunctionSpec | undefined {\n  return AllSpecs.find((spec) => spec.identifier === type)\n}\n\n/**\n * Given a path, read the type first, find the correct spec and load the function.\n *\n * If there is no spec for that type, return undefined.\n * Loading the function can fail if the config fail doesn't follow the given Schema\n */\nexport async function loadFunction(configPath: string): Promise<Result<FunctionInstance, LoadFunctionError>> {\n  const directory = path.dirname(configPath)\n\n  // Read Config file\n  const fileContent = await file.read(configPath)\n  const obj = toml.decode(fileContent)\n\n  // Find spec for the current function type\n  const {type} = TypeSchema.parse(obj)\n  const spec = specForType(type)\n  if (!spec) return err('invalid_function_type')\n\n  // Parse Config file\n  let config\n  try {\n    config = (spec.configSchema ?? BaseFunctionConfigurationSchema).parse(obj)\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch {\n    return err('invalid_function_config')\n  }\n\n  // Parse Metadata file\n  let metadata\n  try {\n    const fileContent = await file.read(path.join(directory, 'metadata.json'))\n    const jsonObj = JSON.parse(fileContent)\n    metadata = (spec.metadataSchema ?? BaseFunctionMetadataSchema).parse(jsonObj)\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch {\n    return err('invalid_function_metadata')\n  }\n\n  const instance = new FunctionInstance(config, metadata, spec, directory)\n  return ok(instance)\n}\n\nexport function createFunctionSpec<\n  TConfiguration extends FunctionConfigType = FunctionConfigType,\n  TMetadata extends MetadataType = MetadataType,\n>(spec: FunctionSpec<TConfiguration, TMetadata>): FunctionSpec<TConfiguration, TMetadata> {\n  const defaults = {\n    templateURL: 'https://github.com/Shopify/function-examples',\n    languages: [\n      {name: 'Wasm', value: 'wasm'},\n      {name: 'Rust', value: 'rust'},\n    ],\n    public: true,\n  }\n  return {...defaults, ...spec}\n}\n"]}