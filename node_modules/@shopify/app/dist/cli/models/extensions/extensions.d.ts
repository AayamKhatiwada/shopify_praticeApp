/// <reference types="node" />
import { BaseExtensionSchema } from './schemas.js';
import { ExtensionPointSpec } from './extension-points.js';
import { AppInterface } from '../app/app.js';
import { schema, api, output } from '@shopify/cli-kit';
import { Result } from '@shopify/cli-kit/common/result';
import { Writable } from 'node:stream';
declare type BaseConfigContents = schema.define.infer<typeof BaseExtensionSchema>;
declare type LoadExtensionError = 'invalid_entry_path' | 'invalid_config' | 'invalid_extension_type';
/**
 * Extension specification with all the needed properties and methods to load an extension.
 */
export interface ExtensionSpec<TConfiguration extends BaseConfigContents = BaseConfigContents> {
    identifier: string;
    dependency?: {
        name: string;
        version: string;
    };
    partnersWebId: string;
    templatePath?: string;
    schema: schema.define.ZodType<TConfiguration>;
    deployConfig?: (config: TConfiguration, directory: string) => Promise<{
        [key: string]: unknown;
    }>;
    preDeployValidation?: (config: TConfiguration) => boolean;
    resourceUrl?: (config: TConfiguration) => string;
    previewMessage?: (host: string, uuid: string, config: TConfiguration, storeFqdn: string) => string | output.TokenizedString;
}
/**
 * Class that represents an instance of a local extension
 * Before creating this class we've validated that:
 * - There is a spec for this type of extension
 * - The Schema for that spec is followed by the extension config toml file
 * - We were able to find an entry point file for that extension
 *
 * It supports extension points, making this Class compatible with both new ui-extension
 * and legacy extension types. Extension points are optional and this class will handle them if present.
 *
 * This class holds the public interface to interact with extensions
 */
export declare class ExtensionInstance<TConfiguration extends BaseConfigContents = BaseConfigContents> {
    entryPath: string;
    outputPath: string;
    devUUID: string;
    localIdentifier: string;
    private config;
    private specification;
    private extensionPointSpecs?;
    private remoteSpecification?;
    private directory;
    get type(): string;
    get humanName(): string | undefined;
    constructor(config: TConfiguration, entryPath: string, directory: string, specification: ExtensionSpec, remoteSpecification?: api.graphql.RemoteSpecification, extensionPointSpecs?: ExtensionPointSpec[]);
    build(stderr: Writable, stdout: Writable, app: AppInterface): Promise<void>;
    deployConfig(): {};
    validate(): boolean;
    resourceUrl(): string | ({
        type: string;
        url: undefined;
    } | {
        type: string;
        url: string;
    })[];
    publishURL(options: {
        orgId: string;
        appId: string;
        extensionId: string;
    }): Promise<string>;
    previewMessage(url: string, storeFqdn: string): string | output.TokenizedString;
    private extensionPointURL;
}
/**
 * Load an extension from given a path.
 * 1. Find the entryPoint file
 * 2. Read the type and find the registered spec for that type.
 * 3. Parse the config file using the schema from the spec
 *
 * If that fails the extension can't be loaded and we'll return an error (to be handled by the caller)
 */
export declare function loadExtension(configPath: string): Promise<Result<ExtensionInstance, LoadExtensionError>>;
export declare function createExtensionSpec<TConfiguration extends BaseConfigContents = BaseConfigContents>(spec: ExtensionSpec<TConfiguration>): ExtensionSpec<TConfiguration>;
export {};
