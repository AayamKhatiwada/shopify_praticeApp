{"version":3,"file":"extensions.js","sourceRoot":"","sources":["../../../../src/cli/models/extensions/extensions.ts"],"names":[],"mappings":"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","sourcesContent":["import {BaseExtensionSchema, TypeSchema, ExtensionPointSchema} from './schemas.js'\nimport {ExtensionPointSpec} from './extension-points.js'\nimport {AppInterface} from '../app/app.js'\nimport {bundleExtension} from '../../services/extensions/bundle.js'\nimport {id, path, schema, toml, api, file, output, environment} from '@shopify/cli-kit'\nimport {err, ok, Result} from '@shopify/cli-kit/common/result'\nimport {Writable} from 'node:stream'\n\n// Base config type that all config schemas must extend.\ntype BaseConfigContents = schema.define.infer<typeof BaseExtensionSchema>\ntype ExtensionPointContents = schema.define.infer<typeof ExtensionPointSchema>\n\n// Array with all registered extensions (locally)\n// PENDING: Register and load all extensions\nconst AllLocalSpecs: ExtensionSpec[] = []\n\ntype LoadExtensionError = 'invalid_entry_path' | 'invalid_config' | 'invalid_extension_type'\n\n/**\n * Extension specification with all the needed properties and methods to load an extension.\n */\nexport interface ExtensionSpec<TConfiguration extends BaseConfigContents = BaseConfigContents> {\n  identifier: string\n  dependency?: {name: string; version: string}\n  partnersWebId: string\n  templatePath?: string\n  schema: schema.define.ZodType<TConfiguration>\n  deployConfig?: (config: TConfiguration, directory: string) => Promise<{[key: string]: unknown}>\n  preDeployValidation?: (config: TConfiguration) => boolean\n  resourceUrl?: (config: TConfiguration) => string\n  previewMessage?: (\n    host: string,\n    uuid: string,\n    config: TConfiguration,\n    storeFqdn: string,\n  ) => string | output.TokenizedString\n}\n\n/**\n * Class that represents an instance of a local extension\n * Before creating this class we've validated that:\n * - There is a spec for this type of extension\n * - The Schema for that spec is followed by the extension config toml file\n * - We were able to find an entry point file for that extension\n *\n * It supports extension points, making this Class compatible with both new ui-extension\n * and legacy extension types. Extension points are optional and this class will handle them if present.\n *\n * This class holds the public interface to interact with extensions\n */\nexport class ExtensionInstance<TConfiguration extends BaseConfigContents = BaseConfigContents> {\n  entryPath: string\n  outputPath: string\n  devUUID: string\n  localIdentifier: string\n\n  private config: TConfiguration\n  private specification: ExtensionSpec\n  private extensionPointSpecs?: ExtensionPointSpec[]\n  private remoteSpecification?: api.graphql.RemoteSpecification\n  private directory: string\n\n  get type() {\n    return this.specification.identifier\n  }\n\n  get humanName() {\n    return this.remoteSpecification?.externalName\n  }\n\n  constructor(\n    config: TConfiguration,\n    entryPath: string,\n    directory: string,\n    specification: ExtensionSpec,\n    remoteSpecification?: api.graphql.RemoteSpecification,\n    extensionPointSpecs?: ExtensionPointSpec[],\n  ) {\n    this.config = config\n    this.entryPath = entryPath\n    this.directory = directory\n    this.specification = specification\n    this.remoteSpecification = remoteSpecification\n    this.extensionPointSpecs = extensionPointSpecs\n    this.outputPath = `${this.directory}/dist/main.js`\n    this.devUUID = `dev-${id.generateRandomUUID()}`\n    this.localIdentifier = path.basename(directory)\n  }\n\n  async build(stderr: Writable, stdout: Writable, app: AppInterface) {\n    await bundleExtension({\n      minify: true,\n      outputBundlePath: this.outputPath,\n      sourceFilePath: this.entryPath,\n      environment: 'production',\n      env: app.dotenv?.variables ?? {},\n      stderr,\n      stdout,\n    })\n    stdout.write(`${this.localIdentifier} successfully built`)\n  }\n\n  deployConfig() {\n    return this.specification.deployConfig?.(this.config, this.directory) ?? {}\n  }\n\n  validate() {\n    if (!this.specification.preDeployValidation) return true\n    return this.specification.preDeployValidation(this.config)\n  }\n\n  resourceUrl() {\n    if (this.extensionPointSpecs) {\n      return this.extensionPointSpecs.map((point) => {\n        const conf = this.config.extension_points?.find((spec) => spec.type === point.type)\n        if (!conf) return {type: point.type, url: undefined}\n        return {type: point.type, url: this.extensionPointURL(point, conf)}\n      })\n    } else {\n      return this.specification.resourceUrl?.(this.config) ?? ''\n    }\n  }\n\n  async publishURL(options: {orgId: string; appId: string; extensionId: string}) {\n    const partnersFqdn = await environment.fqdn.partners()\n    const parnersPath = this.specification.partnersWebId\n    return `https://${partnersFqdn}/${options.orgId}/apps/${options.appId}/extensions/${parnersPath}/${options.extensionId}`\n  }\n\n  previewMessage(url: string, storeFqdn: string) {\n    if (this.specification.previewMessage)\n      return this.specification.previewMessage(url, this.devUUID, this.config, storeFqdn)\n    const publicURL = `${url}/extensions/${this.devUUID}`\n    return output.content`Preview link: ${publicURL}`\n  }\n\n  private extensionPointURL(point: ExtensionPointSpec, config: ExtensionPointContents): string {\n    return point.resourceUrl?.(config) ?? ''\n  }\n}\n\n/**\n * Find the registered spececification for a given extension type\n */\nfunction specForType(type: string): ExtensionSpec | undefined {\n  return AllLocalSpecs.find((spec) => spec.identifier === type)\n}\n\n// PENDING: Fetch remote specs\nfunction remoteSpecForType(type: string): api.graphql.RemoteSpecification | undefined {\n  return undefined\n}\n\n/**\n * Load an extension from given a path.\n * 1. Find the entryPoint file\n * 2. Read the type and find the registered spec for that type.\n * 3. Parse the config file using the schema from the spec\n *\n * If that fails the extension can't be loaded and we'll return an error (to be handled by the caller)\n */\nexport async function loadExtension(configPath: string): Promise<Result<ExtensionInstance, LoadExtensionError>> {\n  const directory = path.dirname(configPath)\n\n  // Find entry paths\n  const entryPath = await path.glob(path.join(directory, 'src', '*.+(ts|js|tsx|jsx)'))\n  if (!entryPath[0]) return err('invalid_entry_path')\n\n  // Read Config file\n  const fileContent = await file.read(configPath)\n  const obj = toml.decode(fileContent)\n  const {type} = TypeSchema.parse(obj)\n\n  // Find spec for this type\n  const localSpec = specForType(type)\n  const remoteSpec = remoteSpecForType(type)\n  if (!localSpec) return err('invalid_extension_type')\n\n  // Parse config for this extension type schema\n  let config\n  try {\n    config = localSpec.schema.parse(obj)\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch {\n    return err('invalid_config')\n  }\n\n  // PENDING: Add support for extension points and validate them\n  const instance = new ExtensionInstance(config, entryPath[0], directory, localSpec, remoteSpec, [])\n  return ok(instance)\n}\n\nexport function createExtensionSpec<TConfiguration extends BaseConfigContents = BaseConfigContents>(\n  spec: ExtensionSpec<TConfiguration>,\n): ExtensionSpec<TConfiguration> {\n  return spec\n}\n"]}