import { ensureDevEnvironment } from './environment.js';
import { generateFrontendURL, generatePartnersURLs, getURLs, shouldOrPromptUpdateURLs, updateURLs } from './dev/urls.js';
import { installAppDependencies } from './dependencies.js';
import { devUIExtensions } from './dev/extension.js';
import { outputAppURL, outputExtensionsMessages, outputUpdateURLsResult } from './dev/output.js';
import { themeExtensionArgs } from './dev/theme-extension-args.js';
import { runConcurrentHTTPProcessesAndPathForwardTraffic, } from '../utilities/app/http-reverse-proxy.js';
import { WebType } from '../models/app/app.js';
import metadata from '../metadata.js';
import { fetchProductVariant } from '../utilities/extensions/fetch-product-variant.js';
import { analytics, port, system, session, string, environment } from '@shopify/cli-kit';
import { execCLI2 } from '@shopify/cli-kit/node/ruby';
import { renderConcurrent } from '@shopify/cli-kit/node/ui';
async function dev(options) {
    const skipDependenciesInstallation = options.skipDependenciesInstallation;
    if (!skipDependenciesInstallation) {
        // eslint-disable-next-line no-param-reassign
        options = {
            ...options,
            app: await installAppDependencies(options.app),
        };
    }
    const token = await session.ensureAuthenticatedPartners();
    const { identifiers, storeFqdn, app, updateURLs: cachedUpdateURLs, tunnelPlugin, } = await ensureDevEnvironment(options, token);
    const apiKey = identifiers.app;
    const { frontendUrl, frontendPort, usingLocalhost } = await generateFrontendURL({
        ...options,
        cachedTunnelPlugin: tunnelPlugin,
    });
    const backendPort = await port.getRandomPort();
    const frontendConfig = options.app.webs.find(({ configuration }) => configuration.type === WebType.Frontend);
    const backendConfig = options.app.webs.find(({ configuration }) => configuration.type === WebType.Backend);
    /** If the app doesn't have web/ the link message is not necessary */
    const exposedUrl = usingLocalhost ? `${frontendUrl}:${frontendPort}` : frontendUrl;
    let shouldUpdateURLs = false;
    if ((frontendConfig || backendConfig) && options.update) {
        const currentURLs = await getURLs(apiKey, token);
        const newURLs = generatePartnersURLs(exposedUrl, backendConfig?.configuration.auth_callback_path);
        shouldUpdateURLs = await shouldOrPromptUpdateURLs({
            currentURLs,
            appDirectory: options.app.directory,
            cachedUpdateURLs,
            newApp: app.newApp,
        });
        if (shouldUpdateURLs)
            await updateURLs(newURLs, apiKey, token);
        await outputUpdateURLsResult(shouldUpdateURLs, newURLs, app);
        outputAppURL(storeFqdn, exposedUrl);
    }
    // If we have a real UUID for an extension, use that instead of a random one
    options.app.extensions.ui.forEach((ext) => (ext.devUUID = identifiers.extensions[ext.localIdentifier] ?? ext.devUUID));
    const backendOptions = {
        apiKey,
        backendPort,
        scopes: options.app.configuration.scopes,
        apiSecret: app.apiSecret ?? '',
        hostname: exposedUrl,
    };
    const proxyTargets = [];
    const proxyPort = usingLocalhost ? await port.getRandomPort() : frontendPort;
    const proxyUrl = usingLocalhost ? `${frontendUrl}:${proxyPort}` : frontendUrl;
    if (options.app.extensions.ui.length > 0) {
        const devExt = await devUIExtensionsTarget({
            app: options.app,
            apiKey,
            url: proxyUrl,
            storeFqdn,
            grantedScopes: app.grantedScopes,
            subscriptionProductUrl: options.subscriptionProductUrl,
            checkoutCartUrl: options.checkoutCartUrl,
        });
        proxyTargets.push(devExt);
    }
    outputExtensionsMessages(options.app, storeFqdn, proxyUrl);
    const additionalProcesses = [];
    if (options.app.extensions.theme.length > 0) {
        const adminSession = await session.ensureAuthenticatedAdmin(storeFqdn);
        const storefrontToken = await session.ensureAuthenticatedStorefront();
        const extension = options.app.extensions.theme[0];
        const args = await themeExtensionArgs(extension, apiKey, token, options);
        const devExt = await devThemeExtensionTarget(args, adminSession, storefrontToken, token);
        additionalProcesses.push(devExt);
    }
    if (backendConfig) {
        additionalProcesses.push(await devBackendTarget(backendConfig, backendOptions));
    }
    if (frontendConfig) {
        const frontendOptions = {
            web: frontendConfig,
            apiKey,
            scopes: options.app.configuration.scopes,
            apiSecret: app.apiSecret ?? '',
            hostname: frontendUrl,
            backendPort,
        };
        if (usingLocalhost) {
            additionalProcesses.push(devFrontendNonProxyTarget(frontendOptions, frontendPort));
        }
        else {
            proxyTargets.push(devFrontendProxyTarget(frontendOptions));
        }
    }
    await logMetadataForDev({ devOptions: options, tunnelUrl: frontendUrl, shouldUpdateURLs, storeFqdn });
    await analytics.reportEvent({ config: options.commandConfig });
    if (proxyTargets.length === 0) {
        await renderConcurrent({ processes: additionalProcesses });
    }
    else {
        await runConcurrentHTTPProcessesAndPathForwardTraffic(proxyPort, proxyTargets, additionalProcesses);
    }
}
function devFrontendNonProxyTarget(options, port) {
    const devFrontend = devFrontendProxyTarget(options);
    return {
        prefix: devFrontend.logPrefix,
        action: async (stdout, stderr, signal) => {
            await devFrontend.action(stdout, stderr, signal, port);
        },
    };
}
function devThemeExtensionTarget(args, adminSession, storefrontToken, token) {
    return {
        prefix: 'extensions',
        action: async (_stdout, _stderr, _signal) => {
            await execCLI2(['extension', 'serve', ...args], { adminSession, storefrontToken, token });
        },
    };
}
function devFrontendProxyTarget(options) {
    const { commands } = options.web.configuration;
    const [cmd, ...args] = commands.dev.split(' ');
    const env = {
        SHOPIFY_API_KEY: options.apiKey,
        SHOPIFY_API_SECRET: options.apiSecret,
        HOST: options.hostname,
        SCOPES: options.scopes,
        BACKEND_PORT: `${options.backendPort}`,
        NODE_ENV: `development`,
    };
    return {
        logPrefix: options.web.configuration.type,
        action: async (stdout, stderr, signal, port) => {
            await system.exec(cmd, args, {
                cwd: options.web.directory,
                stdout,
                stderr,
                env: {
                    ...process.env,
                    ...env,
                    PORT: `${port}`,
                    FRONTEND_PORT: `${port}`,
                    APP_URL: options.hostname,
                    APP_ENV: 'development',
                    // Note: These are Laravel varaibles for backwards compatibility with 2.0 templates.
                    SERVER_PORT: `${port}`,
                },
                signal,
            });
        },
    };
}
async function devBackendTarget(web, options) {
    const { commands } = web.configuration;
    const [cmd, ...args] = commands.dev.split(' ');
    const env = {
        SHOPIFY_API_KEY: options.apiKey,
        SHOPIFY_API_SECRET: options.apiSecret,
        HOST: options.hostname,
        // SERVER_PORT is the convention Artisan uses
        PORT: `${options.backendPort}`,
        SERVER_PORT: `${options.backendPort}`,
        BACKEND_PORT: `${options.backendPort}`,
        SCOPES: options.scopes,
        NODE_ENV: `development`,
        ...(environment.service.isSpinEnvironment() && {
            SHOP_CUSTOM_DOMAIN: `shopify.${await environment.spin.fqdn()}`,
        }),
    };
    return {
        prefix: web.configuration.type,
        action: async (stdout, stderr, signal) => {
            await system.exec(cmd, args, {
                cwd: web.directory,
                stdout,
                stderr,
                signal,
                env: {
                    ...process.env,
                    ...env,
                },
            });
        },
    };
}
async function devUIExtensionsTarget({ app, apiKey, url, storeFqdn, grantedScopes, subscriptionProductUrl, checkoutCartUrl, }) {
    const cartUrl = await buildCartURLIfNeeded(app.extensions.ui, storeFqdn, checkoutCartUrl);
    return {
        logPrefix: 'extensions',
        pathPrefix: '/extensions',
        action: async (stdout, stderr, signal, port) => {
            await devUIExtensions({
                app,
                extensions: app.extensions.ui,
                stdout,
                stderr,
                signal,
                url,
                port,
                storeFqdn,
                apiKey,
                grantedScopes,
                checkoutCartUrl: cartUrl,
                subscriptionProductUrl,
            });
        },
    };
}
/**
 * To prepare Checkout UI Extensions for dev'ing we need to retrieve a valid product variant ID
 * @param extensions - The UI Extensions to dev
 * @param store - The store FQDN
 */
async function buildCartURLIfNeeded(extensions, store, checkoutCartUrl) {
    const hasUIExtension = extensions.map((ext) => ext.type).includes('checkout_ui_extension');
    if (!hasUIExtension)
        return undefined;
    if (checkoutCartUrl)
        return checkoutCartUrl;
    const variantId = await fetchProductVariant(store);
    return `/cart/${variantId}:1`;
}
async function logMetadataForDev(options) {
    const tunnelType = await analytics.getAnalyticsTunnelType(options.devOptions.commandConfig, options.tunnelUrl);
    await metadata.addPublic(() => ({
        cmd_dev_tunnel_type: tunnelType,
        cmd_dev_tunnel_custom_hash: tunnelType === 'custom' ? string.hashString(options.tunnelUrl) : undefined,
        cmd_dev_urls_updated: options.shouldUpdateURLs,
        store_fqdn_hash: string.hashString(options.storeFqdn),
        cmd_app_dependency_installation_skipped: options.devOptions.skipDependenciesInstallation,
        cmd_app_reset_used: options.devOptions.reset,
    }));
    await metadata.addSensitive(() => ({
        store_fqdn: options.storeFqdn,
        cmd_dev_tunnel_custom: tunnelType === 'custom' ? options.tunnelUrl : undefined,
    }));
}
export default dev;
//# sourceMappingURL=dev.js.map