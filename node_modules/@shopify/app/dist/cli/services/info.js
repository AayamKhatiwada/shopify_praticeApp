import { outputEnv } from './app/env/show.js';
import { configurationFileNames, functionExtensions, themeExtensions, uiExtensions, } from '../constants.js';
import { mapExtensionTypeToExternalExtensionType } from '../utilities/extensions/name-mapper.js';
import { os, output, path, store, string } from '@shopify/cli-kit';
import { checkForNewVersion } from '@shopify/cli-kit/node/node-package-manager';
export async function info(app, { format, webEnv }) {
    if (webEnv) {
        return infoWeb(app, { format });
    }
    else {
        return infoApp(app, { format });
    }
}
export async function infoWeb(app, { format }) {
    return outputEnv(app, format);
}
export async function infoApp(app, { format }) {
    if (format === 'json') {
        return output.content `${JSON.stringify(app, null, 2)}`;
    }
    else {
        const appInfo = new AppInfo(app);
        return appInfo.output();
    }
}
const UNKNOWN_TEXT = output.content `${output.token.italic('unknown')}`.value;
const NOT_CONFIGURED_TEXT = output.content `${output.token.italic('Not yet configured')}`.value;
class AppInfo {
    constructor(app) {
        this.app = app;
    }
    async output() {
        const sections = [
            await this.devConfigsSection(),
            this.projectSettingsSection(),
            this.appComponentsSection(),
            this.accessScopesSection(),
            await this.systemInfoSection(),
        ];
        return sections.map((sectionContents) => output.section(...sectionContents)).join('\n\n');
    }
    async devConfigsSection() {
        const title = 'Configs for Dev';
        let appName = NOT_CONFIGURED_TEXT;
        let storeDescription = NOT_CONFIGURED_TEXT;
        let apiKey = NOT_CONFIGURED_TEXT;
        let updateURLs = NOT_CONFIGURED_TEXT;
        let postscript = output.content `ðŸ’¡ These will be populated when you run ${output.token.packagejsonScript(this.app.packageManager, 'dev')}`.value;
        const cachedAppInfo = await store.getAppInfo(this.app.directory);
        if (cachedAppInfo) {
            if (cachedAppInfo.title)
                appName = cachedAppInfo.title;
            if (cachedAppInfo.storeFqdn)
                storeDescription = cachedAppInfo.storeFqdn;
            if (cachedAppInfo.appId)
                apiKey = cachedAppInfo.appId;
            if (cachedAppInfo.updateURLs !== undefined)
                updateURLs = cachedAppInfo.updateURLs ? 'Always' : 'Never';
            postscript = output.content `ðŸ’¡ To change these, run ${output.token.packagejsonScript(this.app.packageManager, 'dev', '--reset')}`.value;
        }
        const lines = [
            ['App', appName],
            ['Dev store', storeDescription],
            ['API key', apiKey],
            ['Update URLs', updateURLs],
        ];
        return [title, `${string.linesToColumns(lines)}\n\n${postscript}`];
    }
    projectSettingsSection() {
        const title = 'Your Project';
        const lines = [
            ['Name', this.app.name],
            ['Root location', this.app.directory],
        ];
        return [title, string.linesToColumns(lines)];
    }
    appComponentsSection() {
        const title = 'Directory Components';
        let body = `\n${this.webComponentsSection()}`;
        function augmentWithExtensions(extensionTypes, extensions, outputFormatter) {
            extensionTypes.forEach((extensionType) => {
                const relevantExtensions = extensions.filter((extension) => {
                    const configurationType = extension.configuration && extension.configuration.type;
                    return configurationType === extensionType;
                });
                if (relevantExtensions[0]) {
                    body += `\n\n${output.content `${output.token.subheading(mapExtensionTypeToExternalExtensionType(extensionType))}`.value}`;
                    relevantExtensions.forEach((extension) => {
                        body += `${outputFormatter(extension)}`;
                    });
                }
            });
        }
        augmentWithExtensions(uiExtensions.types, this.app.extensions.ui, this.uiExtensionSubSection.bind(this));
        augmentWithExtensions(themeExtensions.types, this.app.extensions.theme, this.themeExtensionSubSection.bind(this));
        augmentWithExtensions(functionExtensions.types, this.app.extensions.function, this.functionExtensionSubSection.bind(this));
        const invalidExtensions = Object.values(this.app.extensions)
            .flat()
            .filter((extension) => !extension.configuration || !extension.configuration.type);
        if (invalidExtensions[0]) {
            body += `\n\n${output.content `${output.token.subheading('Extensions with errors')}`.value}`;
            invalidExtensions.forEach((extension) => {
                body += `${this.invalidExtensionSubSection(extension)}`;
            });
        }
        return [title, body];
    }
    webComponentsSection() {
        const errors = [];
        const subtitle = [output.content `${output.token.subheading('web')}`.value];
        const toplevel = ['ðŸ“‚ web', ''];
        const sublevels = [];
        this.app.webs.forEach((web) => {
            if (web.configuration && web.configuration.type) {
                sublevels.push([`  ðŸ“‚ ${web.configuration.type}`, path.relative(this.app.directory, web.directory)]);
            }
            else if (this.app.errors) {
                const error = this.app.errors.getError(`${web.directory}/${configurationFileNames.web}`);
                if (error) {
                    sublevels.push([`  ðŸ“‚ ${UNKNOWN_TEXT}`, path.relative(this.app.directory, web.directory)]);
                    errors.push(error);
                }
            }
        });
        let errorContent = `\n${errors.map(this.formattedError).join('\n')}`;
        if (errorContent.trim() === '')
            errorContent = '';
        return `${subtitle}\n${string.linesToColumns([toplevel, ...sublevels])}${errorContent}`;
    }
    uiExtensionSubSection(extension) {
        const config = extension.configuration;
        const details = [
            [`ðŸ“‚ ${config.name}`, path.relative(this.app.directory, extension.directory)],
            ['     config file', path.relative(extension.directory, extension.configurationPath)],
        ];
        if (config && config.metafields.length) {
            details.push(['     metafields', `${config.metafields.length}`]);
        }
        return `\n${string.linesToColumns(details)}`;
    }
    functionExtensionSubSection(extension) {
        const config = extension.configuration;
        const details = [
            [`ðŸ“‚ ${config.name}`, path.relative(this.app.directory, extension.directory)],
            ['     config file', path.relative(extension.directory, extension.configurationPath)],
        ];
        return `\n${string.linesToColumns(details)}`;
    }
    themeExtensionSubSection(extension) {
        const config = extension.configuration;
        const details = [
            [`ðŸ“‚ ${config.name}`, path.relative(this.app.directory, extension.directory)],
            ['     config file', path.relative(extension.directory, extension.configurationPath)],
        ];
        return `\n${string.linesToColumns(details)}`;
    }
    invalidExtensionSubSection(extension) {
        const details = [
            [`ðŸ“‚ ${UNKNOWN_TEXT}`, path.relative(this.app.directory, extension.directory)],
            ['     config file', path.relative(extension.directory, extension.configurationPath)],
        ];
        const error = this.formattedError(this.app.errors.getError(extension.configurationPath));
        return `\n${string.linesToColumns(details)}\n${error}`;
    }
    formattedError(str) {
        const [errorFirstLine, ...errorRemainingLines] = output.stringifyMessage(str).split('\n');
        const errorLines = [`! ${errorFirstLine}`, ...errorRemainingLines.map((line) => `  ${line}`)];
        return output.content `${output.token.errorText(errorLines.join('\n'))}`.value;
    }
    accessScopesSection() {
        const title = 'Access Scopes in Root TOML File';
        const lines = this.app.configuration.scopes.split(',').map((scope) => [scope]);
        return [title, string.linesToColumns(lines)];
    }
    async systemInfoSection() {
        const title = 'Tooling and System';
        const { platform, arch } = os.platformAndArch();
        const versionUpgradeMessage = await this.versionUpgradeMessage();
        const cliVersionInfo = [this.currentCliVersion(), versionUpgradeMessage].join(' ').trim();
        const lines = [
            ['Shopify CLI', cliVersionInfo],
            ['Package manager', this.app.packageManager],
            ['OS', `${platform}-${arch}`],
            ['Shell', process.env.SHELL || 'unknown'],
            ['Node version', process.version],
        ];
        return [title, `${string.linesToColumns(lines)}`];
    }
    currentCliVersion() {
        return this.app.nodeDependencies['@shopify/cli'];
    }
    async versionUpgradeMessage() {
        const cliDependency = '@shopify/cli';
        const newestVersion = await checkForNewVersion(cliDependency, this.currentCliVersion());
        if (newestVersion) {
            return output.getOutputUpdateCLIReminder(this.app.packageManager, newestVersion);
        }
        return '';
    }
}
//# sourceMappingURL=info.js.map