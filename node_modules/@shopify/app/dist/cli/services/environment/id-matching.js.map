{"version":3,"file":"id-matching.js","sourceRoot":"","sources":["../../../../src/cli/services/environment/id-matching.ts"],"names":[],"mappings":"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","sourcesContent":["import {MatchingError, RemoteSource} from './identifiers.js'\nimport {IdentifiersExtensions} from '../../models/app/identifiers.js'\nimport {err, ok, Result} from '@shopify/cli-kit/common/result'\nimport {string} from '@shopify/cli-kit'\nimport {difference, partition, pickBy, uniqBy, groupBy} from 'lodash-es'\nimport type {LocalSource} from './identifiers'\n\nexport interface MatchResult {\n  identifiers: IdentifiersExtensions\n  toConfirm: {local: LocalSource; remote: RemoteSource}[]\n  toCreate: LocalSource[]\n  toManualMatch: {local: LocalSource[]; remote: RemoteSource[]}\n}\n\n/**\n * Filter function to match a local and a remote source by type and name\n */\nconst sameTypeAndName = (local: LocalSource, remote: RemoteSource) => {\n  return remote.type === local.graphQLType && string.slugify(remote.title) === string.slugify(local.configuration.name)\n}\n\n/**\n * Automatically match local and remote sources if they have the same type and name\n *\n * If multiple local or remote sources have the same type and name, they can't be matched automatically\n */\nfunction matchByNameAndType(\n  local: LocalSource[],\n  remote: RemoteSource[],\n  remoteIdField: 'id' | 'uuid',\n): {matched: IdentifiersExtensions; pending: {local: LocalSource[]; remote: RemoteSource[]}} {\n  const uniqueLocal = uniqBy(local, (elem) => [elem.graphQLType, elem.configuration.name])\n  const uniqueRemote = uniqBy(remote, (elem) => [elem.type, elem.title])\n  const validMatches: IdentifiersExtensions = {}\n\n  uniqueLocal.forEach((localSource) => {\n    const possibleMatch = uniqueRemote.find((remoteSource) => sameTypeAndName(localSource, remoteSource))\n    if (possibleMatch) validMatches[localSource.localIdentifier] = possibleMatch[remoteIdField]\n  })\n\n  const pendingLocal = local.filter((elem) => !validMatches[elem.localIdentifier])\n  const pendingRemote = remote.filter(\n    (registration) => !Object.values(validMatches).includes(registration[remoteIdField]),\n  )\n  return {matched: validMatches, pending: {local: pendingLocal, remote: pendingRemote}}\n}\n\n/**\n * Ask the user to confirm the relationship between a local source and a remote source if they\n * the only ones of their types.\n */\nfunction matchByUniqueType(\n  localSources: LocalSource[],\n  remoteSources: RemoteSource[],\n): {\n  toCreate: LocalSource[]\n  toConfirm: {local: LocalSource; remote: RemoteSource}[]\n  pending: {local: LocalSource[]; remote: RemoteSource[]}\n} {\n  const localGroups = groupBy(localSources, 'graphQLType')\n  const localUnique = Object.values(pickBy(localGroups, (group, key) => group.length === 1)).flat()\n\n  const remoteGroups = groupBy(remoteSources, 'type')\n  const remoteUniqueMap = pickBy(remoteGroups, (group, key) => group.length === 1)\n\n  const toConfirm: {local: LocalSource; remote: RemoteSource}[] = []\n  const toCreate: LocalSource[] = []\n\n  // for every local source that has a unique type we either:\n  // - find a corresponding unique remote source and ask the user to confirm\n  // - create it from scratch\n  for (const local of localUnique) {\n    const remote = remoteUniqueMap[local.graphQLType]\n    if (remote && remote[0]) {\n      toConfirm.push({local, remote: remote[0]})\n    } else {\n      toCreate.push(local)\n    }\n  }\n\n  // now for every local source with a duplicated type we check\n  // if there is a remote source with the same type. if the answer is no,\n  // it means that we need to create them.\n  const localDuplicated = difference(localSources, localUnique)\n  const remotePending = difference(\n    remoteSources,\n    toConfirm.map((elem) => elem.remote),\n  )\n  const [localPending, localToCreate] = partition(localDuplicated, (local) =>\n    remotePending.map((remote) => remote.type).includes(local.graphQLType),\n  )\n  toCreate.push(...localToCreate)\n\n  return {\n    toCreate,\n    toConfirm,\n    pending: {\n      local: localPending,\n      remote: remotePending,\n    },\n  }\n}\n\n/**\n * Automatically match local sources to remote sources.\n * If we can't match a local source to any remote sources, we can create it.\n * If we are unsure about the matching we can ask the user to confirm the relationship.\n */\nexport async function automaticMatchmaking(\n  localSources: LocalSource[],\n  remoteSources: RemoteSource[],\n  identifiers: IdentifiersExtensions,\n  remoteIdField: 'id' | 'uuid',\n): Promise<Result<MatchResult, MatchingError>> {\n  if (remoteSources.length > localSources.length) {\n    return err('invalid-environment')\n  }\n\n  const localUUIDs = Object.values(identifiers)\n  const existsRemotely = (local: LocalSource) => {\n    return Boolean(\n      remoteSources.find(\n        (remote) => remote[remoteIdField] === identifiers[local.localIdentifier] && remote.type === local.graphQLType,\n      ),\n    )\n  }\n\n  // We try to automatically match sources if they have the same name and type,\n  // by considering local sources which are missing on the remote side and\n  // remote sources which are not synchronized locally.\n  const {matched: matchedByNameAndType, pending: matchResult} = matchByNameAndType(\n    localSources.filter((local) => !existsRemotely(local)),\n    remoteSources.filter((remote) => !localUUIDs.includes(remote[remoteIdField])),\n    remoteIdField,\n  )\n\n  // Now we try to find a match between a local source and remote one if they have\n  // the same type and they are unique even if they have different names. For example:\n  // LOCAL_CHECKOUT_UI_NAMED_APPLE -> REMOTE_CHECKOUT_UI_NAMED_PEAR\n  // LOCAL_PROD_SUBSCR_NAMED_ORANGE -> REMOTE_PROD_SUBSCR_NAMED_LEMON\n  const {toConfirm, toCreate, pending} = matchByUniqueType(matchResult.local, matchResult.remote)\n\n  // If we still have remote sources with a type that's missing from the local sources,\n  // or if we have more remote sources than local sources, we return an error\n  const remoteUnmatched = pending.remote.filter(\n    (remote) => !pending.local.map((local) => local.graphQLType).includes(remote.type),\n  )\n  if (remoteUnmatched.length > 0 || pending.remote.length > pending.local.length) {\n    return err('invalid-environment')\n  }\n\n  // At this point, all sources are matched either automatically, manually or are new\n  return ok({\n    identifiers: {...identifiers, ...matchedByNameAndType},\n    toConfirm,\n    toCreate,\n    toManualMatch: pending,\n  })\n}\n"]}