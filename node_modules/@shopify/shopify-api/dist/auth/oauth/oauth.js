"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShopifyOAuth = void 0;
var tslib_1 = require("tslib");
var querystring_1 = tslib_1.__importDefault(require("querystring"));
var uuid_1 = require("uuid");
var cookies_1 = tslib_1.__importDefault(require("cookies"));
var context_1 = require("../../context");
var nonce_1 = tslib_1.__importDefault(require("../../utils/nonce"));
var hmac_validator_1 = tslib_1.__importDefault(require("../../utils/hmac-validator"));
var safe_compare_1 = tslib_1.__importDefault(require("../../utils/safe-compare"));
var decode_session_token_1 = tslib_1.__importDefault(require("../../utils/decode-session-token"));
var session_1 = require("../session");
var http_client_1 = require("../../clients/http_client/http_client");
var types_1 = require("../../clients/http_client/types");
var ShopifyErrors = tslib_1.__importStar(require("../../error"));
var shop_validator_1 = require("../../utils/shop-validator");
var ShopifyOAuth = {
    SESSION_COOKIE_NAME: 'shopify_app_session',
    STATE_COOKIE_NAME: 'shopify_app_state',
    /**
     * Initializes a session and cookie for the OAuth process, and returns the necessary authorization url.
     *
     * @param request Current HTTP Request
     * @param response Current HTTP Response
     * @param shop Shop url: {shop}.myshopify.com
     * @param redirect Redirect url for callback
     * @param isOnline Boolean value. If true, appends 'per-user' grant options to authorization url to receive online access token.
     *                 During final oauth request, will receive back the online access token and current online session information.
     *                 Defaults to online access.
     */
    beginAuth: function (request, response, shop, redirectPath, isOnline) {
        if (isOnline === void 0) { isOnline = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cleanShop, cookies, state, query, queryString;
            return tslib_1.__generator(this, function (_a) {
                context_1.Context.throwIfUninitialized();
                context_1.Context.throwIfPrivateApp('Cannot perform OAuth for private apps');
                cleanShop = (0, shop_validator_1.sanitizeShop)(shop, true);
                cookies = new cookies_1.default(request, response, {
                    keys: [context_1.Context.API_SECRET_KEY],
                    secure: true,
                });
                state = isOnline ? "online_".concat((0, nonce_1.default)()) : "offline_".concat((0, nonce_1.default)());
                cookies.set(ShopifyOAuth.STATE_COOKIE_NAME, state, {
                    signed: true,
                    expires: new Date(Date.now() + 60000),
                    sameSite: 'lax',
                    secure: true,
                });
                query = {
                    client_id: context_1.Context.API_KEY,
                    scope: context_1.Context.SCOPES.toString(),
                    redirect_uri: "".concat(context_1.Context.HOST_SCHEME, "://").concat(context_1.Context.HOST_NAME).concat(redirectPath),
                    state: state,
                    'grant_options[]': isOnline ? 'per-user' : '',
                };
                queryString = querystring_1.default.stringify(query);
                return [2 /*return*/, "https://".concat(cleanShop, "/admin/oauth/authorize?").concat(queryString)];
            });
        });
    },
    /**
     * Validates the received callback query.
     * If valid, will make the subsequent request to update the current session with the appropriate access token.
     * Throws errors for missing sessions and invalid callbacks.
     *
     * @param request Current HTTP Request
     * @param response Current HTTP Response
     * @param query Current HTTP Request Query, containing the information to be validated.
     *              Depending on framework, this may need to be cast as "unknown" before being passed.
     * @param isOnline Boolean value. Defaults to true (online access).
     * @returns SessionInterface
     */
    validateAuthCallback: function (request, response, query) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var stateFromCookie, isOnline, body, postParams, cleanShop, client, postResponse, session, cookies, sessionStored;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context_1.Context.throwIfUninitialized();
                        context_1.Context.throwIfPrivateApp('Cannot perform OAuth for private apps');
                        stateFromCookie = getValueFromCookie(request, response, this.STATE_COOKIE_NAME);
                        deleteCookie(request, response, this.STATE_COOKIE_NAME);
                        if (!stateFromCookie) {
                            throw new ShopifyErrors.CookieNotFound("Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ".concat(query.shop));
                        }
                        if (!validQuery(query, stateFromCookie)) {
                            throw new ShopifyErrors.InvalidOAuthError('Invalid OAuth callback.');
                        }
                        isOnline = stateFromCookie.startsWith('online_');
                        body = {
                            client_id: context_1.Context.API_KEY,
                            client_secret: context_1.Context.API_SECRET_KEY,
                            code: query.code,
                        };
                        postParams = {
                            path: '/admin/oauth/access_token',
                            type: types_1.DataType.JSON,
                            data: body,
                        };
                        cleanShop = (0, shop_validator_1.sanitizeShop)(query.shop, true);
                        client = new http_client_1.HttpClient(cleanShop);
                        return [4 /*yield*/, client.post(postParams)];
                    case 1:
                        postResponse = _a.sent();
                        session = createSession(postResponse, cleanShop, stateFromCookie, isOnline);
                        if (!context_1.Context.IS_EMBEDDED_APP) {
                            cookies = new cookies_1.default(request, response, {
                                keys: [context_1.Context.API_SECRET_KEY],
                                secure: true,
                            });
                            cookies.set(ShopifyOAuth.SESSION_COOKIE_NAME, session.id, {
                                signed: true,
                                expires: session.expires,
                                sameSite: 'lax',
                                secure: true,
                            });
                        }
                        return [4 /*yield*/, context_1.Context.SESSION_STORAGE.storeSession(session)];
                    case 2:
                        sessionStored = _a.sent();
                        if (!sessionStored) {
                            throw new ShopifyErrors.SessionStorageError('Session could not be saved. Please check your session storage functionality.');
                        }
                        return [2 /*return*/, session];
                }
            });
        });
    },
    /**
     * Loads the current session id from the session cookie.
     *
     * @param request HTTP request object
     * @param response HTTP response object
     */
    getCookieSessionId: function (request, response) {
        return getValueFromCookie(request, response, this.SESSION_COOKIE_NAME);
    },
    /**
     * Builds a JWT session id from the current shop and user.
     *
     * @param shop Shopify shop domain
     * @param userId Current actor id
     */
    getJwtSessionId: function (shop, userId) {
        return "".concat((0, shop_validator_1.sanitizeShop)(shop, true), "_").concat(userId);
    },
    /**
     * Builds an offline session id for the given shop.
     *
     * @param shop Shopify shop domain
     */
    getOfflineSessionId: function (shop) {
        return "offline_".concat((0, shop_validator_1.sanitizeShop)(shop, true));
    },
    /**
     * Extracts the current session id from the request / response pair.
     *
     * @param request  HTTP request object
     * @param response HTTP response object
     * @param isOnline Whether to load online (default) or offline sessions (optional)
     */
    getCurrentSessionId: function (request, response, isOnline) {
        if (isOnline === void 0) { isOnline = true; }
        var currentSessionId;
        if (context_1.Context.IS_EMBEDDED_APP) {
            var authHeader = request.headers.authorization;
            if (authHeader) {
                var matches = authHeader.match(/^Bearer (.+)$/);
                if (!matches) {
                    throw new ShopifyErrors.MissingJwtTokenError('Missing Bearer token in authorization header');
                }
                var jwtPayload = (0, decode_session_token_1.default)(matches[1]);
                var shop = jwtPayload.dest.replace(/^https:\/\//, '');
                if (isOnline) {
                    currentSessionId = this.getJwtSessionId(shop, jwtPayload.sub);
                }
                else {
                    currentSessionId = this.getOfflineSessionId(shop);
                }
            }
        }
        // Non-embedded apps will always load sessions using cookies. However, we fall back to the cookie session for
        // embedded apps to allow apps to load their skeleton page after OAuth, so they can set up App Bridge and get a new
        // JWT.
        if (!currentSessionId) {
            // We still want to get the offline session id from the cookie to make sure it's validated
            currentSessionId = getValueFromCookie(request, response, this.SESSION_COOKIE_NAME);
        }
        return currentSessionId;
    },
};
exports.ShopifyOAuth = ShopifyOAuth;
/**
 * Uses the validation utils validateHmac, and safeCompare to assess whether the callback is valid.
 *
 * @param query Current HTTP Request Query
 * @param stateFromCookie state value from the current cookie
 */
function validQuery(query, stateFromCookie) {
    return (0, hmac_validator_1.default)(query) && (0, safe_compare_1.default)(query.state, stateFromCookie);
}
/**
 * Loads a given value from the cookie
 *
 * @param request HTTP request object
 * @param response HTTP response object
 * @param name Name of the cookie to load
 */
function getValueFromCookie(request, response, name) {
    var cookies = new cookies_1.default(request, response, {
        secure: true,
        keys: [context_1.Context.API_SECRET_KEY],
    });
    return cookies.get(name, { signed: true });
}
/**
 * Loads a given value from the cookie
 *
 * @param request HTTP request object
 * @param response HTTP response object
 * @param name Name of the cookie to load
 */
function deleteCookie(request, response, name) {
    var cookies = new cookies_1.default(request, response, {
        secure: true,
        keys: [context_1.Context.API_SECRET_KEY],
    });
    cookies.set(name);
}
/**
 * Creates a new session from the response from the access token request.
 *
 * @param postResponse Response from the access token request
 * @param shop Shop url: {shop}.myshopify.com
 * @param stateFromCookie State from the cookie received by the OAuth callback
 * @param isOnline Boolean indicating if the access token is for online access
 * @returns SessionInterface
 */
function createSession(postResponse, shop, stateFromCookie, isOnline) {
    var session;
    if (isOnline) {
        var sessionId = void 0;
        var responseBody = postResponse.body;
        var access_token = responseBody.access_token, scope = responseBody.scope, rest = tslib_1.__rest(responseBody, ["access_token", "scope"]); // eslint-disable-line @typescript-eslint/naming-convention
        var sessionExpiration = new Date(Date.now() + responseBody.expires_in * 1000);
        if (context_1.Context.IS_EMBEDDED_APP) {
            sessionId = ShopifyOAuth.getJwtSessionId(shop, "".concat(rest.associated_user.id));
        }
        else {
            sessionId = (0, uuid_1.v4)();
        }
        session = new session_1.Session(sessionId, shop, stateFromCookie, isOnline);
        session.accessToken = access_token;
        session.scope = scope;
        session.expires = sessionExpiration;
        session.onlineAccessInfo = rest;
    }
    else {
        var responseBody = postResponse.body;
        session = new session_1.Session(ShopifyOAuth.getOfflineSessionId(shop), shop, stateFromCookie, isOnline);
        session.accessToken = responseBody.access_token;
        session.scope = responseBody.scope;
    }
    return session;
}
