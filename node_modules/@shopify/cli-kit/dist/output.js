/* eslint-disable no-console */
import { isUnitTest, isVerbose } from './environment/local.js';
import colors from './public/node/colors.js';
import { ColorContentToken, CommandContentToken, ErrorContentToken, HeadingContentToken, ItalicContentToken, JsonContentToken, LinesDiffContentToken, LinkContentToken, PathContentToken, RawContentToken, SubHeadingContentToken, } from './content-tokens.js';
import { logToFile } from './log.js';
import stripAnsi from 'strip-ansi';
export { default as logUpdate } from 'log-update';
export class TokenizedString {
    constructor(value) {
        this.value = value;
    }
}
export const token = {
    raw: (value) => {
        return new RawContentToken(value);
    },
    genericShellCommand: (value) => {
        return new CommandContentToken(value);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    json: (value) => {
        return new JsonContentToken(value);
    },
    path: (value) => {
        return new PathContentToken(value);
    },
    link: (value, link) => {
        return new LinkContentToken(value, link);
    },
    heading: (value) => {
        return new HeadingContentToken(value);
    },
    subheading: (value) => {
        return new SubHeadingContentToken(value);
    },
    italic: (value) => {
        return new ItalicContentToken(value);
    },
    errorText: (value) => {
        return new ErrorContentToken(value);
    },
    cyan: (value) => {
        return new ColorContentToken(value, colors.cyan);
    },
    yellow: (value) => {
        return new ColorContentToken(value, colors.yellow);
    },
    magenta: (value) => {
        return new ColorContentToken(value, colors.magenta);
    },
    green: (value) => {
        return new ColorContentToken(value, colors.green);
    },
    packagejsonScript: (packageManager, scriptName, ...scriptArgs) => {
        return new CommandContentToken(formatPackageManagerCommand(packageManager, scriptName, scriptArgs));
    },
    successIcon: () => {
        return new ColorContentToken('âœ”', colors.green);
    },
    failIcon: () => {
        return new ErrorContentToken('âœ–');
    },
    linesDiff: (value) => {
        return new LinesDiffContentToken(value);
    },
};
function formatPackageManagerCommand(packageManager, scriptName, scriptArgs) {
    switch (packageManager) {
        case 'yarn': {
            const pieces = ['yarn', scriptName, ...scriptArgs];
            return pieces.join(' ');
        }
        case 'pnpm':
        case 'npm': {
            const pieces = [packageManager, 'run', scriptName];
            if (scriptArgs.length > 0) {
                pieces.push('--');
                pieces.push(...scriptArgs);
            }
            return pieces.join(' ');
        }
    }
}
export function content(strings, ...keys) {
    let output = ``;
    strings.forEach((string, i) => {
        output += string;
        if (i >= keys.length) {
            return;
        }
        const token = keys[i];
        if (typeof token === 'string') {
            output += token;
        }
        else {
            const enumTokenOutput = token.output();
            if (Array.isArray(enumTokenOutput)) {
                enumTokenOutput.forEach((line) => {
                    output += line;
                });
            }
            else {
                output += enumTokenOutput;
            }
        }
    });
    return new TokenizedString(output);
}
/**
 * It maps a level to a numeric value.
 * @param level - The level for which we'll return its numeric value.
 * @returns The numeric value of the level.
 */
const logLevelValue = (level) => {
    switch (level) {
        case 'trace':
            return 10;
        case 'debug':
            return 20;
        case 'info':
            return 30;
        case 'warn':
            return 40;
        case 'error':
            return 50;
        case 'fatal':
            return 60;
        default:
            return 30;
    }
};
/**
 *
 * @returns It returns the log level set by the user.
 */
export const currentLogLevel = () => {
    if (isVerbose()) {
        return 'debug';
    }
    else {
        return 'info';
    }
};
export const shouldOutput = (logLevel) => {
    if (isUnitTest()) {
        return false;
    }
    const currentLogLevelValue = logLevelValue(currentLogLevel());
    const messageLogLevelValue = logLevelValue(logLevel);
    return messageLogLevelValue >= currentLogLevelValue;
};
// eslint-disable-next-line import/no-mutable-exports
export let collectedLogs = {};
/**
 * This is only used during UnitTesting.
 * If we are in a testing context, instead of printing the logs to the console,
 * we will store them in a variable that can be accessed from the tests.
 * @param key - The key of the log.
 * @param content - The content of the log.
 */
export const collectLog = (key, content) => {
    const output = collectedLogs.output ?? [];
    const data = collectedLogs[key] ?? [];
    data.push(stripAnsi(stringifyMessage(content) ?? ''));
    output.push(stripAnsi(stringifyMessage(content) ?? ''));
    collectedLogs[key] = data;
    collectedLogs.output = output;
};
export const clearCollectedLogs = () => {
    collectedLogs = {};
};
/**
 * Ouputs information to the user.
 * Info messages don't get additional formatting.
 * Note: Info messages are sent through the standard output.
 * @param content - The content to be output to the user.
 * @param logger - The logging function to use to output to the user.
 */
export const info = (content, logger = consoleLog) => {
    const message = stringifyMessage(content);
    if (isUnitTest())
        collectLog('info', content);
    outputWhereAppropriate('info', logger, message);
};
/**
 * Outputs a success message to the user.
 * Success messages receive a special formatting to make them stand out in the console.
 * Note: Success messages are sent through the standard output.
 * @param content - The content to be output to the user.
 * @param logger - The logging function to use to output to the user.
 */
export const success = (content, logger = consoleLog) => {
    const message = colors.bold(`âœ… Success! ${stringifyMessage(content)}.`);
    if (isUnitTest())
        collectLog('success', content);
    outputWhereAppropriate('info', logger, message);
};
/**
 * Outputs a completed message to the user.
 * Completed message receive a special formatting to make them stand out in the console.
 * Note: Completed messages are sent through the standard output.
 * @param content - The content to be output to the user.
 * @param logger - The logging function to use to output to the user.
 */
export const completed = (content, logger = consoleLog) => {
    const message = `${colors.green('âœ”')} ${stringifyMessage(content)}`;
    if (isUnitTest())
        collectLog('completed', content);
    outputWhereAppropriate('info', logger, message);
};
/**
 * Ouputs debug information to the user. By default these output is hidden unless the user calls the CLI with --verbose.
 * Debug messages don't get additional formatting.
 * Note: Debug messages are sent through the standard output.
 * @param content - The content to be output to the user.
 * @param logger - The logging function to use to output to the user.
 */
export const debug = (content, logger = consoleLog) => {
    if (isUnitTest())
        collectLog('debug', content);
    const message = colors.gray(stringifyMessage(content));
    outputWhereAppropriate('debug', logger, message);
};
/**
 * Outputs a warning message to the user.
 * Warning messages receive a special formatting to make them stand out in the console.
 * Note: Warning messages are sent through the standard output.
 * @param content - The content to be output to the user.
 * @param logger - The logging function to use to output to the user.
 */
export const warn = (content, logger = consoleWarn) => {
    if (isUnitTest())
        collectLog('warn', content);
    const message = colors.yellow(stringifyMessage(content));
    outputWhereAppropriate('warn', logger, message);
};
/**
 * Prints a new line in the terminal.
 */
export const newline = () => {
    console.log();
};
export function stringifyMessage(message) {
    if (message instanceof TokenizedString) {
        return message.value;
    }
    else {
        return message;
    }
}
const message = (content, level = 'info') => {
    const stringifiedMessage = stringifyMessage(content);
    outputWhereAppropriate(level, consoleLog, stringifiedMessage);
};
/**
 * This regex can be used to find the erase cursor Ansii characters
 * to strip them from the string.
 * https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797#erase-functions
 */
const eraseCursorAnsiRegex = [
    // Erase the entire line
    '2K',
    // Clear vertical tab stop at current line
    '1G',
]
    .map((element) => `[\\u001B\\u009B][[\\]()#;?]*${element}`)
    .join('|');
export function consoleLog(message) {
    console.log(withOrWithoutStyle(message));
}
export function consoleError(message) {
    console.error(withOrWithoutStyle(message));
}
export function consoleWarn(message) {
    console.warn(withOrWithoutStyle(message));
}
export function outputWhereAppropriate(logLevel, logger, message) {
    if (shouldOutput(logLevel)) {
        logger(message);
    }
    logToFile(message, logLevel.toUpperCase());
}
function withOrWithoutStyle(message) {
    if (shouldDisplayColors()) {
        return message;
    }
    else {
        return unstyled(message);
    }
}
export function unstyled(message) {
    return stripAnsi(message);
}
export function shouldDisplayColors() {
    return Boolean(process.stdout.isTTY || process.env.FORCE_COLOR);
}
/**
 * @param packageManager - The package manager that is being used.
 * @param version - The version to update to
 */
export function getOutputUpdateCLIReminder(packageManager, version) {
    const versionMessage = `ðŸ’¡ Version ${version} available!`;
    if (!packageManager || packageManager === 'unknown')
        return versionMessage;
    const updateCommand = token.packagejsonScript(packageManager, 'shopify', 'upgrade');
    return content `${versionMessage} Run ${updateCommand}`.value;
}
/**
 * Parse title and body to be a single formatted string
 * @param title - The title of the message. Will be formatted as a heading.
 * @param body - The body of the message. Will respect the original formatting.
 * @returns The formatted message.
 */
export function section(title, body) {
    const formattedTitle = `${title.toUpperCase()}${' '.repeat(35 - title.length)}`;
    return content `${token.heading(formattedTitle)}\n${body}`.value;
}
/* eslint-enable no-console */
//# sourceMappingURL=output.js.map