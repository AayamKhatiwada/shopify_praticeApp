import { content as outputContent, token, debug } from './output.js';
import fs from 'fs-extra';
import del from 'del';
import { temporaryDirectoryTask } from 'tempy';
import { sep, join, extname } from 'pathe';
import prettier from 'prettier';
const DEFAULT_PRETTIER_CONFIG = {
    arrowParens: 'always',
    singleQuote: true,
    bracketSpacing: false,
    trailingComma: 'all',
};
export function stripUp(path, strip) {
    const parts = path.split(sep);
    return join(...parts.slice(strip));
}
/**
 * Creates a temporary directory and ties its lifecycle to the lifecycle of the callback.
 * @param callback - The callback that receives the temporary directory.
 */
export async function inTemporaryDirectory(callback) {
    return temporaryDirectoryTask(callback);
}
/**
 * It reads a file and returns its content as a string using the
 * utf-8 encoding
 * @param path - Path to the file to read.
 * @returns A promise that resolves with the content of the file.
 */
export async function read(path, options = { encoding: 'utf-8' }) {
    debug(outputContent `Reading the content of file at ${token.path(path)}...`);
    const content = await fs.readFile(path, options);
    return content;
}
/**
 * Given a path, it determines the actual path. This is useful when working
 * with paths that represent symlinks.
 * @param path - Path whose real path will be returned.
 */
export async function realpath(path) {
    return fs.promises.realpath(path);
}
export function readSync(path, options = { encoding: 'utf-8' }) {
    debug(outputContent `Sync-reading the content of file at ${token.path(path)}...`);
    const content = fs.readFileSync(path, options);
    return content.toString();
}
/**
 * Copies a file
 * @param from - Path to the directory or file to be copied.
 * @param to - Destination path.
 */
export async function copy(from, to) {
    debug(outputContent `Copying file from ${token.path(from)} to ${token.path(to)}...`);
    await fs.copy(from, to);
}
export async function touch(path) {
    debug(outputContent `Creating an empty file at ${token.path(path)}...`);
    await fs.ensureFile(path);
}
export async function appendFile(path, content) {
    debug(outputContent `Appending the following content to ${token.path(path)}:
    ${content
        .split('\n')
        .map((line) => `  ${line}`)
        .join('\n')}
  `);
    await fs.appendFile(path, content);
}
export function touchSync(path) {
    debug(outputContent `Creating an empty file at ${token.path(path)}...`);
    fs.ensureFileSync(path);
}
export async function write(path, data) {
    debug(outputContent `Writing some content to file at ${token.path(path)}...`);
    await fs.writeFile(path, data);
}
export function writeSync(path, data) {
    debug(outputContent `File-writing some content to file at ${token.path(path)}...`);
    fs.writeFileSync(path, data);
}
export async function append(path, data) {
    await fs.appendFile(path, data);
}
export function appendSync(path, data) {
    fs.appendFileSync(path, data);
}
export async function mkdir(path) {
    debug(outputContent `Creating directory at ${token.path(path)}...`);
    await fs.mkdirp(path);
}
export function mkdirSync(path) {
    debug(outputContent `Sync-creating directory at ${token.path(path)}...`);
    fs.mkdirpSync(path);
}
export async function remove(path) {
    debug(outputContent `Removing file at ${token.path(path)}...`);
    await fs.remove(path);
}
export function removeSync(path) {
    debug(outputContent `Sync-removing file at ${token.path(path)}...`);
    fs.removeSync(path);
}
export async function rmdir(path, { force } = {}) {
    debug(outputContent `Removing directory at ${token.path(path)}...`);
    await del(path, { force });
}
export async function mkTmpDir() {
    debug(outputContent `Creating a temporary directory...`);
    const directory = await fs.mkdtemp('tmp-');
    return directory;
}
export async function isDirectory(path) {
    debug(outputContent `Checking if ${token.path(path)} is a directory...`);
    return (await fs.promises.lstat(path)).isDirectory();
}
export async function size(path) {
    debug(outputContent `Getting the size of file file at ${token.path(path)}...`);
    return (await fs.stat(path)).size;
}
export function sizeSync(path) {
    debug(outputContent `Sync-getting the size of file file at ${token.path(path)}...`);
    return fs.statSync(path).size;
}
export function createReadStream(path) {
    return fs.createReadStream(path);
}
/**
 * Returns the Date object for the last modification of a file.
 * @param path - Path to the directory or file.
 * @returns A unix timestamp.
 */
export async function lastUpdated(path) {
    debug(outputContent `Getting last updated timestamp for file at ${token.path(path)}...`);
    return (await fs.stat(path)).ctime;
}
/**
 * Returns the unix timestamp of the last modification of a file.
 * @param path - Path to the directory or file.
 * @returns A unix timestamp.
 */
export async function lastUpdatedTimestamp(path) {
    try {
        const lastUpdatedDateTime = await lastUpdated(path);
        return lastUpdatedDateTime.getTime();
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch {
        return undefined;
    }
}
/**
 * Moves a file.
 * @param src - File to be moved.
 * @param dest - Path to be moved to.
 * @param options - Moving options.
 */
export async function move(src, dest, options = {}) {
    await fs.move(src, dest, options);
}
/**
 * Changes the permissions of a directory or file.
 * @param path - Path to the file or directory whose permissions will be modified.
 * @param mode - Permissions to set to the file or directory.
 */
export async function chmod(path, mode) {
    await fs.promises.chmod(path, mode);
}
/**
 * Checks if a file has executable permissions.
 * @param path - Path to the file whose permissions will be checked.
 */
export async function hasExecutablePermissions(path) {
    try {
        await fs.promises.access(path, fs.constants.X_OK);
        return true;
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch {
        return false;
    }
}
/**
 * Returns true if a file or directory exists
 * @param path - Path to the directory or file.
 * @returns True if it exists.
 */
export async function exists(path) {
    try {
        await fs.promises.access(path);
        return true;
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch {
        return false;
    }
}
/**
 * Format a string using prettier. Return the formatted content.
 */
export async function format(content, options) {
    const ext = extname(options.path);
    const prettierConfig = {
        ...DEFAULT_PRETTIER_CONFIG,
        parser: 'babel',
    };
    switch (ext) {
        case '.html':
        case '.css':
            prettierConfig.parser = ext.slice(1);
            break;
    }
    const formattedContent = await prettier.format(content, prettierConfig);
    return formattedContent;
}
//# sourceMappingURL=file.js.map