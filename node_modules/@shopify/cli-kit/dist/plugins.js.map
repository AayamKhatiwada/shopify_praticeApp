{"version":3,"file":"plugins.js","sourceRoot":"","sources":["../src/plugins.ts"],"names":[],"mappings":"AAIA,OAAO,EAAC,0BAA0B,EAAE,0BAA0B,EAAC,MAAM,0BAA0B,CAAA;AAC/F,OAAO,EAAC,GAAG,EAAS,MAAM,2BAA2B,CAAA;AAGrD;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,MAAyB,EACzB,KAAa,EACb,OAA4C,EAC5C,OAAgB;IAEhB,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,CAAA;IACzD,8DAA8D;IAC9D,OAAO,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAC,MAAM,EAAE,MAAM,EAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAQ,CAAA;AAClG,CAAC;AA4CD;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,sBAAsB,CAAC,MAAc;IACzD,MAAM,KAAK,GAAG,MAAM,WAAW,CAAC,MAAM,EAAE,iBAAiB,EAAE,EAAE,CAAC,CAAA;IAC9D,MAAM,KAAK,GAAG,0BAA0B,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAA;IACtF,IAAI,0BAA0B,CAAC,KAAK,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,+BAA+B,EAAC,CAAA;IACtG,OAAO,EAAC,OAAO,EAAE,KAAK,EAAC,CAAA;AACzB,CAAC;AAQD;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,MAAc,EACd,IAAY,EACZ,QAAgB;IAEhB,MAAM,KAAK,GAAG,MAAM,WAAW,CAAC,MAAM,EAAE,cAAc,EAAE,EAAC,IAAI,EAAE,QAAQ,EAAC,CAAC,CAAA;IACzE,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,CAC5C,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC,cAAc,EAAE,KAAK,EAAE,IAAI,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,kBAAkB,CACjG,CAAA;IACD,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC;QAAE,OAAO,GAAG,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,eAAe,EAAC,CAAC,CAAA;IACxE,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAAE,OAAO,GAAG,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,aAAa,EAAC,CAAC,CAAA;IAE1F,OAAO,UAAU,CAAC,CAAC,CAAC;SACjB,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC;SACvB,QAAQ,CAAC,CAAC,KAAK,EAAE,EAAE,CAClB,KAAK,CAAC,IAAI,KAAK,SAAS;QACtB,CAAC,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAC;QACrD,CAAC,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,eAAe,EAAC,CACtC,CAAA;AACL,CAAC","sourcesContent":["import {JsonMap} from './json.js'\nimport {PickByPrefix} from './typing/pick-by-prefix.js'\nimport {MonorailEventPublic, MonorailEventSensitive} from './monorail.js'\nimport {HookReturnPerTunnelPlugin} from './public/node/plugins/tunnel.js'\nimport {getArrayContainsDuplicates, getArrayRejectingUndefined} from './public/common/array.js'\nimport {err, Result} from './public/common/result.js'\nimport {Config, Interfaces} from '@oclif/core'\n\n/**\n * Convenience function to trigger a hook, and gather any successful responses. Failures are ignored.\n *\n * Responses are organised into a dictionary, keyed by plug-in name. Only plug-ins that have hooks registered for the given event, and the hooks were run successfully, are included.\n */\nexport async function fanoutHooks<TPluginMap extends HookReturnsPerPlugin, TEvent extends string & keyof TPluginMap>(\n  config: Interfaces.Config,\n  event: TEvent,\n  options: TPluginMap[typeof event]['options'],\n  timeout?: number,\n): Promise<Partial<TPluginMap[typeof event]['pluginReturns']>> {\n  const res = await config.runHook(event, options, timeout)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return Object.fromEntries(res.successes.map(({result, plugin}) => [plugin.name, result])) as any\n}\n\ntype AppSpecificMonorailFields = PickByPrefix<MonorailEventPublic, 'app_', 'project_type' | 'api_key' | 'partner_id'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_extensions_'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_scaffold_'>\n\ntype AppSpecificSensitiveMonorailFields = PickByPrefix<MonorailEventSensitive, 'app_'>\n\ninterface HookReturnsPerPlugin extends HookReturnPerTunnelPlugin {\n  public_command_metadata: {\n    options: {[key: string]: never}\n    pluginReturns: {\n      '@shopify/app': Partial<AppSpecificMonorailFields>\n      [pluginName: string]: JsonMap\n    }\n  }\n  sensitive_command_metadata: {\n    options: {[key: string]: never}\n    pluginReturns: {\n      '@shopify/app': Partial<AppSpecificSensitiveMonorailFields>\n      [pluginName: string]: JsonMap\n    }\n  }\n  [hookName: string]: {\n    options: {[key: string]: unknown}\n    pluginReturns: {[key: string]: JsonMap | Result<JsonMap, Error>}\n  }\n}\n\nexport type PluginReturnsForHook<\n  TEvent extends keyof TPluginMap,\n  TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'],\n  TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin,\n> = TPluginMap[TEvent]['pluginReturns'][TPluginName]\n\nexport type FanoutHookFunction<\n  TEvent extends keyof TPluginMap = string,\n  TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'] = string,\n  TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin,\n> = (\n  this: Interfaces.Hook.Context,\n  options: TPluginMap[TEvent]['options'] & {config: Interfaces.Config},\n) => Promise<PluginReturnsForHook<TEvent, TPluginName, TPluginMap>>\n\n/**\n * Execute the 'tunnel_provider' hook, and return the list of available tunnel providers.\n * Fail if there are multiple plugins for the same provider\n *\n * @param config - oclif config used to execute hooks\n * @returns list of available tunnel plugins\n */\nexport async function getListOfTunnelPlugins(config: Config): Promise<{plugins: string[]; error?: string}> {\n  const hooks = await fanoutHooks(config, 'tunnel_provider', {})\n  const names = getArrayRejectingUndefined(Object.values(hooks).map((key) => key?.name))\n  if (getArrayContainsDuplicates(names)) return {plugins: names, error: 'multiple-plugins-for-provider'}\n  return {plugins: names}\n}\n\nexport interface TunnelPluginError {\n  provider: string\n  type: 'multiple-urls' | 'handled-error' | 'unknown' | 'no-provider'\n  message?: string\n}\n\n/**\n * Execute the 'tunnel_start' hook for the given provider.\n * Fails if there aren't plugins for that provider or if there are more than one.\n *\n * @param config - oclif config used to execute hooks\n * @param port - port where the tunnel will be started\n * @param provider - selected provider, must be unique\n * @returns tunnel URL from the selected provider\n */\nexport async function runTunnelPlugin(\n  config: Config,\n  port: number,\n  provider: string,\n): Promise<Result<string, TunnelPluginError>> {\n  const hooks = await fanoutHooks(config, 'tunnel_start', {port, provider})\n  const urlResults = Object.values(hooks).filter(\n    (tunnelResponse) => !tunnelResponse?.isErr() || tunnelResponse.error.type !== 'invalid-provider',\n  )\n  if (urlResults.length > 1) return err({provider, type: 'multiple-urls'})\n  if (urlResults.length === 0 || !urlResults[0]) return err({provider, type: 'no-provider'})\n\n  return urlResults[0]\n    .map((data) => data.url)\n    .mapError((error) =>\n      error.type === 'unknown'\n        ? {provider, type: 'unknown', message: error.message}\n        : {provider, type: 'handled-error'},\n    )\n}\n"]}