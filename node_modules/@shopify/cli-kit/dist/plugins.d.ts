import { JsonMap } from './json.js';
import { PickByPrefix } from './typing/pick-by-prefix.js';
import { MonorailEventPublic, MonorailEventSensitive } from './monorail.js';
import { HookReturnPerTunnelPlugin } from './public/node/plugins/tunnel.js';
import { Result } from './public/common/result.js';
import { Config, Interfaces } from '@oclif/core';
/**
 * Convenience function to trigger a hook, and gather any successful responses. Failures are ignored.
 *
 * Responses are organised into a dictionary, keyed by plug-in name. Only plug-ins that have hooks registered for the given event, and the hooks were run successfully, are included.
 */
export declare function fanoutHooks<TPluginMap extends HookReturnsPerPlugin, TEvent extends string & keyof TPluginMap>(config: Interfaces.Config, event: TEvent, options: TPluginMap[typeof event]['options'], timeout?: number): Promise<Partial<TPluginMap[typeof event]['pluginReturns']>>;
declare type AppSpecificMonorailFields = PickByPrefix<MonorailEventPublic, 'app_', 'project_type' | 'api_key' | 'partner_id'> & PickByPrefix<MonorailEventPublic, 'cmd_extensions_'> & PickByPrefix<MonorailEventPublic, 'cmd_scaffold_'>;
declare type AppSpecificSensitiveMonorailFields = PickByPrefix<MonorailEventSensitive, 'app_'>;
interface HookReturnsPerPlugin extends HookReturnPerTunnelPlugin {
    public_command_metadata: {
        options: {
            [key: string]: never;
        };
        pluginReturns: {
            '@shopify/app': Partial<AppSpecificMonorailFields>;
            [pluginName: string]: JsonMap;
        };
    };
    sensitive_command_metadata: {
        options: {
            [key: string]: never;
        };
        pluginReturns: {
            '@shopify/app': Partial<AppSpecificSensitiveMonorailFields>;
            [pluginName: string]: JsonMap;
        };
    };
    [hookName: string]: {
        options: {
            [key: string]: unknown;
        };
        pluginReturns: {
            [key: string]: JsonMap | Result<JsonMap, Error>;
        };
    };
}
export declare type PluginReturnsForHook<TEvent extends keyof TPluginMap, TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'], TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin> = TPluginMap[TEvent]['pluginReturns'][TPluginName];
export declare type FanoutHookFunction<TEvent extends keyof TPluginMap = string, TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'] = string, TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin> = (this: Interfaces.Hook.Context, options: TPluginMap[TEvent]['options'] & {
    config: Interfaces.Config;
}) => Promise<PluginReturnsForHook<TEvent, TPluginName, TPluginMap>>;
/**
 * Execute the 'tunnel_provider' hook, and return the list of available tunnel providers.
 * Fail if there are multiple plugins for the same provider
 *
 * @param config - oclif config used to execute hooks
 * @returns list of available tunnel plugins
 */
export declare function getListOfTunnelPlugins(config: Config): Promise<{
    plugins: string[];
    error?: string;
}>;
export interface TunnelPluginError {
    provider: string;
    type: 'multiple-urls' | 'handled-error' | 'unknown' | 'no-provider';
    message?: string;
}
/**
 * Execute the 'tunnel_start' hook for the given provider.
 * Fails if there aren't plugins for that provider or if there are more than one.
 *
 * @param config - oclif config used to execute hooks
 * @param port - port where the tunnel will be started
 * @param provider - selected provider, must be unique
 * @returns tunnel URL from the selected provider
 */
export declare function runTunnelPlugin(config: Config, port: number, provider: string): Promise<Result<string, TunnelPluginError>>;
export {};
