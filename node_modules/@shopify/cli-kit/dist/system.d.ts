/// <reference types="node" />
import { AbortSignal } from 'abort-controller';
import type { Writable, Readable } from 'node:stream';
export interface ExecOptions {
    cwd?: string;
    env?: {
        [key: string]: string | undefined;
    };
    stdin?: Readable | 'inherit';
    stdout?: Writable | 'inherit';
    stderr?: Writable | 'inherit';
    stdio?: 'inherit';
    input?: string;
    signal?: AbortSignal;
}
export declare type WritableExecOptions = Omit<ExecOptions, 'stdout'> & {
    stdout?: Writable;
};
export declare const open: (url: string) => Promise<void>;
/**
 * Runs a command asynchronously, aggregates the stdout data, and returns it.
 * @param command - Command to be executed.
 * @param args - Arguments to pass to the command.
 * @returns A promise that resolves with the aggregatted stdout of the command.
 */
export declare const captureOutput: (command: string, args: string[], options?: ExecOptions | undefined) => Promise<string>;
export declare const exec: (command: string, args: string[], options?: ExecOptions | undefined) => Promise<void>;
interface ConcurrentExecCommand {
    prefix: string;
    executable: string;
    args: string[];
    cwd: string;
}
/**
 * Runs commands concurrently and combines the standard output and error data
 * into a single stream. See {@link renderConcurrent} for more information about
 * the output format.
 *
 * If one of the processes fails, it aborts the running ones and exits with that error.
 * @param commands - Commands to execute.
 */
export declare const concurrentExec: (commands: ConcurrentExecCommand[]) => Promise<void>;
/**
 * Displays a large file using the terminal pager set by the user, or a
 * reasonable default for the user's OS:
 *
 * @param filename - The path to the file to be displayed.
 */
export declare function page(filename: string): Promise<void>;
export declare function sleep(seconds: number): Promise<unknown>;
export {};
