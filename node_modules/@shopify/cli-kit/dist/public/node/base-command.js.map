{"version":3,"file":"base-command.js","sourceRoot":"","sources":["../../../src/public/node/base-command.ts"],"names":[],"mappings":"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","sourcesContent":["import {errorHandler, registerCleanBugsnagErrorsFromWithinPlugins} from './error-handler.js'\nimport {loadPresetsFromDirectory} from './presets.js'\nimport {JsonMap} from '../../json.js'\nimport {isDevelopment} from '../../environment/local.js'\nimport {Abort} from '../../error.js'\nimport {addPublic} from '../../metadata.js'\nimport {content, info, token} from '../../output.js'\nimport {hashString} from '../../string.js'\nimport {initiateLogging} from '../../log.js'\nimport {Command, Interfaces} from '@oclif/core'\n\ninterface PresettableFlags {\n  preset?: string\n  path?: string\n}\n\nabstract class BaseCommand extends Command {\n  public static analyticsNameOverride(): string | undefined {\n    return undefined\n  }\n\n  async catch(error: Error & {exitCode?: number | undefined}) {\n    await errorHandler(error, this.config)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected async init(): Promise<any> {\n    if (!isDevelopment()) {\n      // This function runs just prior to `run`\n      await registerCleanBugsnagErrorsFromWithinPlugins(this.config)\n    }\n    await initiateLogging()\n    return super.init()\n  }\n\n  protected async parse<\n    TFlags extends Interfaces.FlagOutput & {path?: string; verbose?: boolean},\n    TArgs extends Interfaces.OutputArgs,\n  >(\n    options?: Interfaces.Input<TFlags> | undefined,\n    argv?: string[] | undefined,\n  ): Promise<Interfaces.ParserOutput<TFlags, TArgs>> {\n    let result = await super.parse<TFlags, TArgs>(options, argv)\n    result = await this.resultWithPreset<TFlags, TArgs>(options, argv, result)\n    await addFromParsedFlags(result.flags)\n    return result\n  }\n\n  protected async resultWithPreset<\n    TFlags extends Interfaces.FlagOutput & {path?: string; verbose?: boolean},\n    TArgs extends Interfaces.OutputArgs,\n  >(\n    options: Interfaces.Input<TFlags> | undefined,\n    argv: string[] | undefined,\n    originalResult: Interfaces.ParserOutput<TFlags, TArgs>,\n  ): Promise<Interfaces.ParserOutput<TFlags, TArgs>> {\n    // If no preset is specified, don't modify the results\n    const flags = originalResult.flags as PresettableFlags\n    if (!flags.preset) return originalResult\n\n    // If the specified preset isn't found, don't modify the results\n    const presets = await loadPresetsFromDirectory(await this.presetsPath(flags), {findUp: this.findUpForPresets()})\n    const preset = presets[flags.preset]\n    if (!preset) return originalResult\n\n    // Parse using noDefaultsOptions to derive a list of flags specified as\n    // command-line arguments.\n    const noDefaultsResult = await super.parse<TFlags, TArgs>(noDefaultsOptions(options), argv)\n\n    // Add the preset's settings to argv and pass them to `super.parse`. This\n    // invokes oclif's validation system without breaking the oclif black box.\n    // Replace the original result with this one.\n    const result = await super.parse<TFlags, TArgs>(options, [\n      // Need to specify argv default because we're merging with argsFromPreset.\n      ...(argv || this.argv),\n      ...argsFromPreset<TFlags, TArgs>(preset, options, noDefaultsResult),\n    ])\n\n    // Report successful application of the preset.\n    reportPresetApplication<TFlags, TArgs>(noDefaultsResult.flags, result.flags, flags.preset, preset)\n\n    return result\n  }\n\n  protected async presetsPath(rawFlags: {path?: string}): Promise<string> {\n    return rawFlags.path || process.cwd()\n  }\n\n  protected findUpForPresets(): boolean {\n    return true\n  }\n}\n\nexport async function addFromParsedFlags(flags: {path?: string; verbose?: boolean}) {\n  await addPublic(() => ({\n    cmd_all_verbose: flags.verbose,\n    cmd_all_path_override: flags.path !== undefined,\n    cmd_all_path_override_hash: flags.path === undefined ? undefined : hashString(flags.path),\n  }))\n}\n\n/**\n * Any flag which is:\n *\n * 1. Present in the final set of flags\n * 2. Specified in the preset\n * 3. Not specified by the user as a command line argument\n *\n * should be reported.\n *\n * It doesn't matter if the preset flag's value was the same as the default; from\n * the user's perspective, they want to know their preset was applied.\n */\nfunction reportPresetApplication<TFlags extends Interfaces.FlagOutput, TArgs extends Interfaces.OutputArgs>(\n  noDefaultsFlags: Interfaces.ParserOutput<TFlags, TArgs>['flags'],\n  flagsWithPresets: Interfaces.ParserOutput<TFlags, TArgs>['flags'],\n  presetName: string,\n  preset: JsonMap,\n): void {\n  const changes: JsonMap = {}\n  for (const [name, value] of Object.entries(flagsWithPresets)) {\n    const userSpecifiedThisFlag = Object.prototype.hasOwnProperty.call(noDefaultsFlags, name)\n    const presetContainsFlag = Object.prototype.hasOwnProperty.call(preset, name)\n    if (!userSpecifiedThisFlag && presetContainsFlag) changes[name] = value\n  }\n  if (Object.keys(changes).length === 0) return\n  info(content`Using applicable flags from the preset ${token.yellow(presetName)}:\n\n${Object.entries(changes)\n  .map(([name, value]) => `â€¢ ${name} = ${value}`)\n  .join('\\n')}\\n`)\n}\n\n/**\n * Strips the defaults from configured flags. For example, if flags contains:\n *\n * ```\n *   someFlag: Flags.boolean({\n *     description: 'some flag',\n *     default: false\n *   })\n * ```\n *\n * it becomes:\n *\n * ```\n *   someFlag: Flags.boolean({\n *     description: 'some flag'\n *   })\n * ```\n *\n * If we parse using this configuration, the only specified flags will be those\n * the user actually passed on the command line.\n */\n\nfunction noDefaultsOptions<TFlags extends Interfaces.FlagOutput>(\n  options: Interfaces.Input<TFlags> | undefined,\n): Interfaces.Input<TFlags> | undefined {\n  if (!options?.flags) return options\n  return {\n    ...options,\n    flags: Object.fromEntries(\n      Object.entries(options.flags).map(([label, settings]) => {\n        const copiedSettings = {...(settings as {default?: unknown})}\n        delete copiedSettings.default\n        return [label, copiedSettings]\n      }),\n    ) as Interfaces.FlagInput<TFlags>,\n  }\n}\n\n/**\n * Converts the preset's settings to arguments as though passed on the command\n * line, skipping any arguments the user specified on the command line.\n */\nfunction argsFromPreset<TFlags extends Interfaces.FlagOutput, TArgs extends Interfaces.OutputArgs>(\n  preset: JsonMap,\n  options: Interfaces.Input<TFlags> | undefined,\n  noDefaultsResult: Interfaces.ParserOutput<TFlags, TArgs>,\n): string[] {\n  const args: string[] = []\n  for (const [label, value] of Object.entries(preset)) {\n    const flagIsRelevantToCommand = options?.flags && Object.prototype.hasOwnProperty.call(options.flags, label)\n    const userSpecifiedThisFlag =\n      noDefaultsResult.flags && Object.prototype.hasOwnProperty.call(noDefaultsResult.flags, label)\n    if (flagIsRelevantToCommand && !userSpecifiedThisFlag) {\n      if (typeof value === 'boolean') {\n        if (value === true) {\n          args.push(`--${label}`)\n        } else {\n          throw new Abort(\n            content`Presets can only specify true for boolean flags. Attempted to set ${token.yellow(label)} to false.`,\n          )\n        }\n      } else if (Array.isArray(value)) {\n        value.forEach((element) => args.push(`--${label}`, `${element}`))\n      } else {\n        args.push(`--${label}`, `${value}`)\n      }\n    }\n  }\n  return args\n}\n\nexport default BaseCommand\n"]}