{"version":3,"file":"node-package-manager.js","sourceRoot":"","sources":["../../../src/public/node/node-package-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {AbortError, BugError} from './error.js'\nimport {exec} from '../../system.js'\nimport {exists as fileExists, read as readFile, write as writeFile} from '../../file.js'\nimport {glob, dirname, join as pathJoin, findUp} from '../../path.js'\nimport {latestNpmPackageVersion} from '../../version.js'\nimport {Version} from '../../semver.js'\nimport {content, token, debug} from '../../output.js'\nimport {AbortController, AbortSignal} from 'abort-controller'\nimport type {Writable} from 'node:stream'\nimport type {ExecOptions} from '../../system.js'\n\n/** The name of the Yarn lock file */\nexport const yarnLockfile = 'yarn.lock'\n\n/** The name of the pnpm lock file */\nexport const pnpmLockfile = 'pnpm-lock.yaml'\n\n/** The name of the pnpm workspace file */\nexport const pnpmWorkspaceFile = 'pnpm-workspace.yaml'\n\n/** An array containing the lockfiles from all the package managers */\nexport const lockfiles = [yarnLockfile, pnpmLockfile]\n\n/**\n * A union type that represents the type of dependencies in the package.json\n * - dev: devDependencies\n * - prod: dependencies\n * - peer: peerDependencies\n */\nexport type DependencyType = 'dev' | 'prod' | 'peer'\n\n/**\n * A union that represents the package managers available.\n */\nexport const packageManager = ['yarn', 'npm', 'pnpm'] as const\nexport type PackageManager = typeof packageManager[number]\n\n/**\n * Returns an abort error that's thrown when a directory that's expected to have\n * a package.json doesn't have it.\n * @param directory - The path to the directory that should contain a package.json\n * @returns An abort error.\n */\nexport const PackageJsonNotFoundError = (directory: string) => {\n  return new AbortError(`The directory ${directory} doesn't have a package.json.`)\n}\n\n/**\n * Returns a bug error that's thrown when the lookup of the package.json traversing the directory\n * hierarchy up can't find a package.json\n * @param directory - The directory from which the traverse has been done\n * @returns An abort error.\n */\nexport const FindUpAndReadPackageJsonNotFoundError = (directory: string) => {\n  return new BugError(content`Couldn't find a a package.json traversing directories from ${token.path(directory)}`)\n}\n\n/**\n * Returns the dependency manager used to run the create workflow.\n * @param env - The environment variables of the process in which the CLI runs.\n * @returns The dependency manager\n */\nexport function packageManagerUsedForCreating(env = process.env): PackageManager | 'unknown' {\n  if (env.npm_config_user_agent?.includes('yarn')) {\n    return 'yarn'\n  } else if (env.npm_config_user_agent?.includes('pnpm')) {\n    return 'pnpm'\n  } else if (env.npm_config_user_agent?.includes('npm')) {\n    return 'npm'\n  }\n  return 'unknown'\n}\n\n/**\n * Returns the dependency manager used by an existing project.\n * @param directory - The root directory of the project.\n * @returns The dependency manager\n */\nexport async function getPackageManager(directory: string): Promise<PackageManager> {\n  debug(content`Obtaining the dependency manager in directory ${token.path(directory)}...`)\n  const yarnLockPath = pathJoin(directory, yarnLockfile)\n  const pnpmLockPath = pathJoin(directory, pnpmLockfile)\n  if (await fileExists(yarnLockPath)) {\n    return 'yarn'\n  } else if (await fileExists(pnpmLockPath)) {\n    return 'pnpm'\n  } else {\n    return 'npm'\n  }\n}\n\ninterface InstallNPMDependenciesRecursivelyOptions {\n  /**\n   * The dependency manager to use to install the dependencies.\n   */\n  packageManager: PackageManager\n  /**\n   * The directory from where we'll find package.json's recursively\n   */\n  directory: string\n\n  /**\n   * Specifies the maximum depth of the glob search.\n   */\n  deep?: number\n}\n\n/**\n * This function traverses down a directory tree to find directories containing a package.json\n * and installs the dependencies if needed. To know if it's needed, it uses the \"check\" command\n * provided by dependency managers.\n * @param options - Options to install dependencies recursively.\n */\nexport async function installNPMDependenciesRecursively(options: InstallNPMDependenciesRecursivelyOptions) {\n  const packageJsons = await glob(pathJoin(options.directory, '**/package.json'), {\n    ignore: [pathJoin(options.directory, 'node_modules/**/package.json')],\n    cwd: options.directory,\n    onlyFiles: true,\n    deep: options.deep,\n  })\n  const abortController = new AbortController()\n  try {\n    await Promise.all(\n      packageJsons.map(async (packageJsonPath) => {\n        const directory = dirname(packageJsonPath)\n        await installNodeModules({\n          directory,\n          packageManager: options.packageManager,\n          stdout: undefined,\n          stderr: undefined,\n          signal: abortController.signal,\n          args: [],\n        })\n      }),\n    )\n  } catch (error) {\n    abortController.abort()\n    throw error\n  }\n}\n\ninterface InstallNodeModulesOptions {\n  directory: string\n  args: string[]\n  packageManager: PackageManager\n  stdout?: Writable\n  stderr?: Writable\n  signal?: AbortSignal\n}\n\nexport async function installNodeModules(options: InstallNodeModulesOptions) {\n  const execOptions: ExecOptions = {\n    cwd: options.directory,\n    stdin: undefined,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  }\n  let args = ['install']\n  if (options.args) {\n    args = args.concat(options.args)\n  }\n  await exec(options.packageManager, args, execOptions)\n}\n\n/**\n * Returns the name of the package configured in its package.json\n * @param packageJsonPath - Path to the package.json file\n * @returns A promise that resolves with the name.\n */\nexport async function getPackageName(packageJsonPath: string): Promise<string | undefined> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  return packageJsonContent.name\n}\n\n/**\n * Returns the list of production and dev dependencies of a package.json\n * @param packageJsonPath - Path to the package.json file\n * @returns A promise that resolves with the list of dependencies.\n */\nexport async function getDependencies(packageJsonPath: string): Promise<{[key: string]: string}> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  const dependencies: {[key: string]: string} = packageJsonContent.dependencies ?? {}\n  const devDependencies: {[key: string]: string} = packageJsonContent.devDependencies ?? {}\n\n  return {...dependencies, ...devDependencies}\n}\n\n/**\n * Returns true if the app uses workspaces, false otherwise.\n * @param packageJsonPath - Path to the package.json file\n * @param pnpmWorkspacePath - Path to the pnpm-workspace.yaml file\n * @returns A promise that resolves with true if the app uses workspaces, false otherwise.\n */\nexport async function usesWorkspaces(appDirectory: string): Promise<boolean> {\n  const packageJsonPath = pathJoin(appDirectory, 'package.json')\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  const pnpmWorkspacePath = pathJoin(appDirectory, pnpmWorkspaceFile)\n  return Boolean(packageJsonContent.workspaces) || fileExists(pnpmWorkspacePath)\n}\n\n/**\n * Given an NPM dependency, it checks if there's a more recent version, and if there is, it returns its value.\n * @param dependency - The dependency name (e.g. react)\n * @param currentVersion - The current version.\n * @returns A promise that resolves with a more recent version or undefined if there's no more recent version.\n */\nexport async function checkForNewVersion(dependency: string, currentVersion: string): Promise<string | undefined> {\n  debug(content`Checking if there's a version of ${dependency} newer than ${currentVersion}`)\n  try {\n    const lastVersion = await latestNpmPackageVersion(dependency)\n    if (lastVersion && new Version(currentVersion).compare(lastVersion) < 0) {\n      return lastVersion\n    } else {\n      return undefined\n    }\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch (error) {\n    return undefined\n  }\n}\n\n/**\n * An interface that represents a package.json\n */\nexport interface PackageJson {\n  /**\n   * The name attribute of the package.json\n   */\n  name?: string\n\n  /**\n   * The version attribute of the package.json\n   */\n  version?: string\n\n  /**\n   * The dependencies attribute of the package.json\n   */\n  dependencies?: {[key: string]: string}\n\n  /**\n   * The devDependencies attribute of the package.json\n   */\n  devDependencies?: {[key: string]: string}\n\n  /**\n   * The optional oclif settings attribute of the package.json\n   */\n  oclif?: {\n    plugins?: string[]\n  }\n\n  /**\n   * The workspaces attribute of the package.json\n   */\n  workspaces?: string[]\n\n  /**\n   * The resolutions attribute of the package.json. Only useful when using yarn as package manager\n   */\n  resolutions?: {[key: string]: string}\n\n  /**\n   * The overrides attribute of the package.json. Only useful when using npm o npmn as package managers\n   */\n  overrides?: {[key: string]: string}\n}\n\n/**\n * Reads and parses a package.json\n * @param packageJsonPath - Path to the package.json\n * @returns An promise that resolves with an in-memory representation\n *    of the package.json or rejects with an error if the file is not found or the content is\n *    not decodable.\n */\nexport async function readAndParsePackageJson(packageJsonPath: string): Promise<PackageJson> {\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(dirname(packageJsonPath))\n  }\n  return JSON.parse(await readFile(packageJsonPath))\n}\n\ninterface AddNPMDependenciesIfNeededOptions {\n  /** How dependencies should be added */\n  type: DependencyType\n\n  /** The dependency manager to use to add dependencies */\n  packageManager: PackageManager\n\n  /** The directory that contains the package.json where dependencies will be added */\n  directory: string\n\n  /** Standard output coming from the underlying installation process */\n  stdout?: Writable\n\n  /** Standard error coming from the underlying installation process */\n  stderr?: Writable\n\n  /** Abort signal to stop the process */\n  signal?: AbortSignal\n}\n\n/**\n * An interface that represents a dependency name with its version\n */\nexport interface DependencyVersion {\n  /**\n   * The name of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   * In the example below name would be \"react\"\n   * ```\n   * {\n   *   \"react\": \"1.2.3\"\n   * }\n   * ```\n   */\n  name: string\n\n  /**\n   * The version of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   * In the example below version would be \"1.2.3\"\n   * ```\n   * {\n   *   \"react\": \"1.2.3\"\n   * }\n   * ```\n   */\n  version: string | undefined\n}\n\n/**\n * Adds dependencies to a Node project (i.e. a project that has a package.json)\n * @param dependencies - List of dependencies to be added.\n * @param options - Options for adding dependencies.\n */\nexport async function addNPMDependenciesIfNeeded(\n  dependencies: DependencyVersion[],\n  options: AddNPMDependenciesIfNeededOptions,\n) {\n  debug(content`Adding the following dependencies if needed:\n${token.json(dependencies)}\nWith options:\n${token.json(options)}\n  `)\n  const packageJsonPath = pathJoin(options.directory, 'package.json')\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(options.directory)\n  }\n  const existingDependencies = Object.keys(await getDependencies(packageJsonPath))\n  let dependenciesToAdd = dependencies\n  dependenciesToAdd = dependencies.filter((dep) => {\n    return !existingDependencies.includes(dep.name)\n  })\n  if (dependenciesToAdd.length === 0) {\n    return\n  }\n  await addNPMDependencies(dependenciesToAdd, options)\n}\n\nexport async function addNPMDependencies(\n  dependencies: DependencyVersion[],\n  options: AddNPMDependenciesIfNeededOptions,\n) {\n  let args: string[]\n  const depedenciesWithVersion = dependencies.map((dep) => {\n    return dep.version ? `${dep.name}@${dep.version}` : dep.name\n  })\n  switch (options.packageManager) {\n    case 'npm':\n      args = argumentsToAddDependenciesWithNPM(depedenciesWithVersion, options.type)\n      break\n    case 'yarn':\n      args = argumentsToAddDependenciesWithYarn(depedenciesWithVersion, options.type)\n      break\n    case 'pnpm':\n      args = argumentsToAddDependenciesWithPNPM(depedenciesWithVersion, options.type)\n      break\n  }\n  options.stdout?.write(`Executing... ${[options.packageManager, ...args].join(' ')}`)\n  await exec(options.packageManager, args, {\n    cwd: options.directory,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  })\n}\n\nexport async function addNPMDependenciesWithoutVersionIfNeeded(\n  dependencies: string[],\n  options: AddNPMDependenciesIfNeededOptions,\n) {\n  await addNPMDependenciesIfNeeded(\n    dependencies.map((dependency) => {\n      return {name: dependency, version: undefined}\n    }),\n    options,\n  )\n}\n\n/**\n * Returns the arguments to add dependencies using NPM.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithNPM(dependencies: string[], type: DependencyType): string[] {\n  let command = ['install']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using Yarn.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithYarn(dependencies: string[], type: DependencyType): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--dev')\n      break\n    case 'peer':\n      command.push('--peer')\n      break\n    case 'prod':\n      command.push('--prod')\n      break\n  }\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using PNPM.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithPNPM(dependencies: string[], type: DependencyType): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  return command\n}\n\n/**\n * Given a directory it traverses the directory up looking for a package.json and if found, it reads it\n * decodes the JSON, and returns its content as a Javascript object.\n * @param options - The directory from which traverse up.\n * @returns If found, the promise resolves with the path to the\n *  package.json and its content. If not found, it throws a FindUpAndReadPackageJsonNotFoundError error.\n */\nexport async function findUpAndReadPackageJson(fromDirectory: string): Promise<{path: string; content: unknown}> {\n  const packageJsonPath = await findUp('package.json', {cwd: fromDirectory, type: 'file'})\n  if (packageJsonPath) {\n    const packageJson = JSON.parse(await readFile(packageJsonPath))\n    return {path: packageJsonPath, content: packageJson}\n  } else {\n    throw FindUpAndReadPackageJsonNotFoundError(fromDirectory)\n  }\n}\n\nexport async function addResolutionOrOverride(directory: string, dependencies: {[key: string]: string}) {\n  const packageManager = await getPackageManager(directory)\n  const packageJsonPath = pathJoin(directory, 'package.json')\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n\n  if (packageManager === 'yarn') {\n    packageJsonContent.resolutions = packageJsonContent.resolutions\n      ? {...packageJsonContent.resolutions, ...dependencies}\n      : dependencies\n  }\n  if (packageManager === 'npm' || packageManager === 'pnpm') {\n    packageJsonContent.overrides = packageJsonContent.overrides\n      ? {...packageJsonContent.overrides, ...dependencies}\n      : dependencies\n  }\n\n  await writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2))\n}\n"]}