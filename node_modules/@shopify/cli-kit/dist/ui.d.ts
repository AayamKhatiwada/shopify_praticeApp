import { Listr as OriginalListr, ListrTask, ListrBaseClassOptions } from 'listr2';
export declare function newListr(tasks: ListrTask[], options?: object | ListrBaseClassOptions): OriginalListr<any, any, "verbose">;
export declare type ListrTasks = ConstructorParameters<typeof OriginalListr>[0];
export type { ListrTaskWrapper, ListrDefaultRenderer, ListrTask } from 'listr2';
export interface Question<TName extends string = string> {
    name: TName;
    message: string;
    preface?: string;
    validate?: (value: string) => string | true;
    default?: string;
    result?: (value: string) => string | boolean;
    type: 'input' | 'select' | 'autocomplete' | 'password';
    choices?: QuestionChoiceType[];
}
export interface QuestionChoiceType {
    name: string;
    value: string;
    group?: {
        name: string;
        order: number;
    };
}
/**
 * Performs a task with the title kept up to date and stdout available to the
 * task while it runs (there is no re-writing stdout while the task runs).
 */
export interface TaskOptions {
    title: string;
    task: () => Promise<void | {
        successMessage: string;
    }>;
}
export declare const task: ({ title, task }: TaskOptions) => Promise<void>;
export declare const prompt: <TName extends string & keyof TAnswers, TAnswers extends { [key in TName]: string; } = { [key_1 in TName]: string; }>(questions: readonly Question<TName>[]) => Promise<TAnswers>;
export declare function nonEmptyDirectoryPrompt(directory: string): Promise<void>;
export declare function terminateBlockingPortProcessPrompt(port: number, stepDescription?: string): Promise<boolean>;
export declare const keypress: () => Promise<unknown>;
